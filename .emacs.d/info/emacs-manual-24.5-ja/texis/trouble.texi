@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c This is part of the Emacs manual.
@c Copyright (C) 1985-1987, 1993-1995, 1997, 2001-2015 Free Software
@c Foundation, Inc.
@c See file emacs.texi for copying conditions.
@iftex
@chapter 一般的な問題への対処

  意図しないコマンドをタイプした場合、その結果は不可解なことが多くあります。このチャプターでは、間違いをキャンセルしたり、不可解な状況から復帰するために何ができるかを示します。Emacsのバグとシステムクラッシュについても考察します。
@end iftex

@ifnottex
@raisesections
@end ifnottex

@node Quitting
@section 中止と中断
@cindex quitting

@table @kbd
@item C-g
@itemx C-@key{Break} @r{(MS-DOSのみ)}
quit(中止): コマンドの実行、または途中までタイプしたコマンドをキャンセルします。
@item C-]
最内の再帰編集レベル(recursive editing
level)をabort(中断)して、それを呼び出したコマンドをキャンセルします(@code{abort-recursive-edit})。
@item @key{ESC} @key{ESC} @key{ESC}
quitまたはabortのどちらか、意味のあるほうを行ないます(@code{keyboard-escape-quit})。
@item M-x top-level
現在実行中のすべての再帰編集レベルをabortします。
@item C-/
@itemx C-x u
@itemx C-_
バッファー内容にたいする直前の変更をキャンセルします(@code{undo})。
@end table

  完了する前のコマンドをキャンセルする方法は2つあります。それは@kbd{C-g}による@dfn{quit}と、@kbd{C-]}や@kbd{M-x
top-level}による@dfn{abort}です。quitは途中までタイプしたコマンド、または実行中のコマンドをキャンセルします。abortは再帰編集レベルを抜けて、再帰編集を呼び出したコマンドをキャンセルします(@ref{Recursive
Edit}を参照してください)。

@cindex quitting
@kindex C-g
  @kbd{C-g}によるquitは、途中までタイプしたコマンドから抜けたり、望まない数引数から抜け出す方法です。さらに、あるコマンドが実行中の場合、@kbd{C-g}は比較的安全にコマンドを停止します。たとえば、長い時間がかかるkillコマンドをquitした場合、@emph{すべて}のテキストがバッファーに残るか、または@emph{すべて}のテキストがkillリングに残るか、もしかしたらその両方かもしれません。リージョンがアクティブの場合、Transient
Markモードがオフでなければ、@kbd{C-g}はマークを非アクティブにします(@ref{Disabled Transient
Mark}を参照してください)。インクリメンタル検索の途中では、@kbd{C-g}は特別に振る舞います。検索を抜けるには2回連続して@kbd{C-g}をタイプします。詳細は、@ref{Incremental
Search}を参照してください。

  MS-DOSでは、文字@kbd{C-@key{Break}}が@kbd{C-g}のような文字の役割をします。MS-DOSではユーザーとの相互作用を行なうとき以外に、実行中のコマンドで@kbd{C-g}を認識できないのが理由です。それとは対照的に、@kbd{C-@key{Break}}は常に認識できます。
@iftex
@ref{MS-DOS Keyboard,,,emacs-xtra, Specialized Emacs Features}を参照してください。
@end iftex
@ifnottex
@ref{MS-DOS Keyboard}を参照してください。
@end ifnottex

@findex keyboard-quit
  @kbd{C-g}をタイプした瞬間に変数@code{quit-flag}を@code{t}にセットすることにより、@kbd{C-g}は機能します。Emacs
Lispはこの変数を頻繁にチェックして、これが非@code{nil}のときはquitします。Emacsが入力待ちのときにタイプしたときだけ、@kbd{C-g}は実際にコマンドとして実行されます。この場合に実行されるコマンドは、@code{keyboard-quit}です。

  テキスト端末では、最初の@kbd{C-g}が認識される前に2回目の@kbd{C-g}でquitした場合は、``emergency
escape(緊急エスケープ)''機能がアクティブになり、シェルに戻ります。@ref{Emergency Escape}を参照してください。

@cindex NFS and quitting
  quitできない状況もいくつか存在します。Emacsがオペレーティングシステムが何か行なうのを待つような場合、待ちが発生する箇所で特定のシステムコールにたいして、Emacsが特別な対処をしない場合、quitは不可能です。ユーザーがquitしたいと望むようなシステムコールにたいして、わたしたちはこれを行なっていなすが、それでも処理できないケースに出会う場合もあります。とても一般的なケースの1つは、NFSを使用したファイルへの入出力待ちです。Emacs自体はquitする方法を知っていますが、多くのNFS実装は、NFSサーバーがハングしたとき、ユーザープログラムがNFSを待つのを止めることを、単に許していません。

@cindex aborting recursive edit
@findex abort-recursive-edit
@kindex C-]
  @kbd{C-]}
(@code{abort-recursive-edit})によるabortは、再帰編集レベルを抜けて、それを呼び出したコマンドをキャンセルするのに使用されます。@kbd{C-g}によるquitはこれを行なわず、行なうこともできません。なぜならこれは再帰編集レベルの@emph{中}で、途中までタイプされたコマンドをキャンセルするからです。どちらの操作も有用です。たとえば再帰編集中に、数引数を入力するために@kbd{C-u
8}とタイプした場合、@kbd{C-g}でその引数をキャンセルして、その再帰編集レベルに留まることができます。

@findex keyboard-escape-quit
@kindex ESC ESC ESC
  シーケンス@kbd{@key{ESC} @key{ESC} @key{ESC}}
(@code{keyboard-escape-quit})は、quitかabortのどちらかを呼び出します(多くのPCプログラムで@key{ESC}は``抜け出す''ことを意味するので、このような定義にしました)。これは@kbd{C-g}のように、プレフィクス引数のキャンセル、選択されたリージョンのクリアー、また問い合わせつき置換から抜け出すこともできます。また@kbd{C-]}のように、ミニバッファーから抜け出したり、再帰編集から抜け出すこともできます。これは@kbd{C-x
1}のように、フレームの複数ウィンドウ分割から抜け出すこともできます。これが行なうことができないのは、実行中のコマンドの停止です。これは通常のコマンドとして実行されるので、Emacsが次のコマンドのために準備ができるまで、これを認識しないからです。

@findex top-level
  コマンド@kbd{M-x
top-level}は、現在の再帰編集レベルからすべての再帰編集レベルを抜けるための、``充分''な回数の@kbd{C-]}コマンドと等価です。ミニバッファーがアクティブなときは、ミニバッファーも抜けます。@kbd{C-]}は、1度に1レベル再帰編集レベルを抜けますが、@kbd{M-x
top-level}は、1度ですべての再帰編集レベルを抜けます。@kbd{C-]}と@kbd{M-x
top-level}の両方とも、他のすべてのコマンドと同様(そして@kbd{C-g}とは異なり)、Emacsがコマンドにたいして準備ができているときだけ効果があります。@kbd{C-]}は通常のキーで、このキーが意味をもつのは、それがキーマップでバインドされているときだけです。@ref{Recursive
Edit}を参照してください。

  厳密に言えば@kbd{C-/}
(@code{undo})はキャンセルコマンドではありませんが、すでに実行を終えたコマンドをキャンセルすると考えることができます。undo機能についての詳細は、@ref{Undo}を参照してください。

@node Lossage
@section Emacsのトラブルへの対処
@cindex troubleshooting Emacs

  このセクションでは、キーボードコードのミクスアップ(mixup)、文字化け、メモリー不足、クラッシュやハングなど、Emacsが期待したとおりに動作しない状況の認識と対処法について説明します。

  Emacsでバグを見つけたと思ったら何をすればよいかについては、@ref{Bugs}を参照してください。

@menu
* DEL Does Not Delete::      @key{DEL}で削除できないとき、何を行なうべきか。
* Stuck Recursive::          モードラインのカッコの周囲の`[...]'。
* Screen Garbled::           画面上のゴミ。
* Text Garbled::             テキストの中のゴミ。
* Memory Full::              メモリー不足に対処する方法。
* Crashing::                 クラッシュ時にEmacsが何を行なうか。
* After a Crash::            クラッシュしたEmacsセッションでの編集をリカバリーする。
* Emergency Escape::         Emacsが応答しなくなったとき、何を行なうべきか。
@end menu

@node DEL Does Not Delete
@subsection @key{DEL}で削除できない場合
@cindex @key{DEL} vs @key{BACKSPACE}
@cindex @key{BACKSPACE} vs @key{DEL}
@cindex @key{DEL} does not delete

  すべてのキーボードには多くのキーがありますが、通常@key{BACKSPACE}とラベルされたキーは、最後にタイプした文字を削除するのに使用されます。Emacsでは、このキーは@key{DEL}に等しいと想定されています。

  グラフィカルなディスプレーでEmacsを開始したとき、Emacsはどのキーが@key{DEL}なのか自動的に決定します。いくつかの特殊なケースでは、Emacsがシステムから間違った情報を取得して、@key{BACKSPACE}が後方ではなく前方に削除する場合があります。

  @key{Delete}というキーをもつキーボードもあります。これは通常、前方に削除するために使用されます。Emacsでこのキーが後方に削除を行なう場合も、Emacsが間違った情報
--- ただし反対の意味の --- を受け取ったことを意味します。

  テキスト端末で、@key{BACKSPACE}が文字を削除するかわりに、@kbd{Control-h}のようなヘルプコマンドのプロンプトを表示する場合、それはこのキーが実際は@samp{BS}文字を送っていることを意味します。Emacsは@key{BS}を@key{DEL}と扱うべきですが、そうしていないのです。

@findex normal-erase-is-backspace-mode
  これらのケースのすべてにおいて、直ちに改善できることは同じでで、それはコマンド@kbd{M-x
normal-erase-is-backspace-mode}を使用する方法です。これはEmacsが@key{DEL}の処理をサポートする2つのモードを切り替えるので、もしEmacsが間違ったモードで開始された場合、正しいモードに切り替えることができます。テキスト端末では、@key{BS}が@key{DEL}として扱われる場合にヘルプを見たいときは、@key{F1}を使用します。@kbd{C-?}が文字コード127を送る場合は、このキーも機能するでしょう。

  すべてのEmacsセッションで問題を解決するには、初期化ファイル(@ref{Init
File}を参照してください)に以下の行の1つを記述します。上記の最初のケースでは、@key{BACKSPACE}が後方ではなく前方に削除を行なうので、@key{BACKSPACE}が@key{DEL}として動作するように、以下の行を使用します:

@lisp
(normal-erase-is-backspace-mode 0)
@end lisp

@noindent
他の2つのケースでは、以下の行を使用します:

@lisp
(normal-erase-is-backspace-mode 1)
@end lisp

@vindex normal-erase-is-backspace
  すべてのEmacsセッションで問題を解決する別の方法は、変数@code{normal-erase-is-backspace}をカスタマイズする方法です。@key{BS}または@key{BACKSPACE}が@key{DEL}となるようにモードを指定するには値@code{t}、他のモードにたいしては@code{nil}を指定します。@ref{Easy
Customization}を参照してください。

@node Stuck Recursive
@subsection 再帰編集レベル
@cindex stuck in recursive editing
@cindex recursive editing, cannot exit

  再帰編集レベルは、Emacsの重要かつ便利な機能ですが、それを理解していない場合は、うまく機能していないように見えるかもしれません。

  モードラインの、メジャーモードやマイナーモードを囲む丸カッコ(parentheses)の周囲に、角カッコ(square
brackets)@samp{[@dots{}]}がある場合、それは再帰編集レベルにいることを意味します。もしこれが目的でない場合、またはその意味を理解していない場合は、すぐに再帰編集レベルを抜けるべきです。これを行なうには、@kbd{M-x
top-level}とタイプします。@ref{Recursive Edit}を参照してください。

@node Screen Garbled
@subsection スクリーン上のゴミ
@cindex garbled display
@cindex display, incorrect
@cindex screen display, wrong

  テキスト端末でテキストが間違って見える場合、まず行なうことはバッファーのテキストが間違っていないか確かめることです。画面全体を再描画するために、@kbd{C-l}とタイプしてください。この後でスクリーンが正常に表示される場合、問題は前のスクリーンの更新にあります(そうでない場合は、以下のセクションを参照してください)。

  ディスプレー更新の問題は、使用している端末にたいする間違ったterminfoエントリーの結果であることがしばしばあります。Emacsディストリビューションのファイル@file{etc/TERMS}は、この種の既知の問題にたいする解決を与えます。@file{INSTALL}のセクションの中の1つは、これらの問題にたいする一般的なアドバイスを含みます。正しいterminfoエントリーを使用しているようなら、それはterminfoエントリーにバグがあるか、特定の端末タイプで発生するEmacsのバグである可能性があります。

@node Text Garbled
@subsection テキスト内のゴミ
@cindex garbled text
@cindex buffer text garbled

  @kbd{C-l}がそのテキストが間違っていることを示す場合、最初に実際の結果を生成するのに何のコマンドをタイプしたか見るために、@kbd{C-h
l}とタイプします。それから@kbd{C-x u}を使用して、正しいと思える状態まで、1つずつ変更をundoします。

  バッファーの先頭または最後の大量のテキストが失われているように見える場合は、モードラインに単語@samp{Narrow}が表示されていないかチェックします。もしこれが表示されている場合、表示されていないテキストはまだ存在しますが、一時的に制限されています。これに再びアクセスできるようにするには、@kbd{C-x
n w}とタイプします。@ref{Narrowing}を参照してください。

@node Memory Full
@subsection メモリー不足
@cindex memory full
@cindex out of memory

  @samp{Virtual memory exceeded}というエラーメッセージが表示された場合は、@kbd{C-x
s}で変更されたバッファーを保存してください。この方法は、バッファーを保存するのに最小限の追加メモリーを必要とします。Emacsはこのエラーが発生したときでも利用可能な予備メモリーを保持しており、それは@kbd{C-x
s}が処理を完了するのに充分なはずです。予備メモリーを使用したとき、モードラインの先頭に@samp{!MEM
FULL!}が表示された場合、それは予備メモリーも使い切ったことを意味します。

  変更されたバッファーを変更したら、このEmacsセッションを終了して別のセッションを開始するか、@kbd{M-x
kill-some-buffers}を使用して、カレントEmacsジョブのスペースを開放できます。これにより充分なスペースが開放された場合、予備メモリーは再充填され、モードラインから@samp{!MEM
FULL!}の表示が消えます。これは同じEmacsセッションで、安全に編集を継続できることを意味します。

  メモリー不足のときは、バッファーの保存やkillに@kbd{M-x buffer-menu}を使用しないでください。Buffer
Menuはかなりの量のメモリーを必要とするので、予備メモリーの供給では不充分でしょう。

@node Crashing
@subsection Emacsがクラッシュしたとき

@cindex crash report
@cindex backtrace
@cindex @file{emacs_backtrace.txt} file, MS-Windows
  Emacsはクラッシュを前提としていませんが、もしクラッシュした場合、exitする前に@dfn{クラッシュレポート(crash
report)}を生成します。クラッシュレポートは標準エラーストリームにプリントされます。EmacsがGNUシステムまたはUnixシステムでグラフィカルなデスクトップから開始された場合、標準エラーストリームは一般的に@file{~/.xsession-errors}のようなファイルにリダイレクトされるので、そこでクラッシュレポートを探すことができます。MS-Windowsでは、クラッシュレポートは標準エラーストリームに加え、Emacsプロセスのカレントとディレクトリーの、@file{emacs_backtrace.txt}という名前のファイルに書き込まれます。

  クラッシュレポートのフォーマットは、プラットフォームに依存します。GNU
Cライブラリーを使用するいくつかのプラットフォームでは、クラッシュレポートには、クラッシュ前の実行状態を説明する@dfn{backtrace}が含まれ、これはクラッシュをデバッグする助けとなります。以下はGNUシステムの例です:

@example
Fatal error 11: Segmentation fault
Backtrace:
emacs[0x5094e4]
emacs[0x4ed3e6]
emacs[0x4ed504]
/lib64/libpthread.so.0[0x375220efe0]
/lib64/libpthread.so.0(read+0xe)[0x375220e08e]
emacs[0x509af6]
emacs[0x5acc26]
@dots{}
@end example

@noindent
数字@samp{11} はクラッシュにたいするシステムのシグナル番号 --- このケースではsegmentation fault ---
です。16進数字はプログラムのアドレスで、これによりデバッグツールを使用して、ソースコード行に関連付けることができます。たとえばGDBコマンド@samp{list
*0x509af6}は、@samp{emacs[0x509af6]}エントリーにたいするソースコード行をプリントします。システムに@command{addr2line}ユーティリティーがある場合、以下のシェルコマンドはソースコードの行番号とともに、backtraceを出力します:

@example
sed -n 's/.*\[\(.*\)]$/\1/p' @var{backtrace} |
  addr2line -C -f -i -p -e @var{bindir}/@var{emacs-binary}
@end example

@noindent
ここで、@var{backtrace}はbacktraceのコピーを含むテキストファイル名、@var{bindir}はEmacs実行可能ファイルを含むディレクトリー名、@var{emacs-binary}はEmacs実行可能ファイル(GNUおよびUnixシステムでは通常は@file{emacs}、MS-WindowsおよびMS-DOSでは@file{emacs.exe})です。@option{-p}オプションがない古いバージョンの@command{addr2line}では、このオプションを省略してください。

@cindex core dump
  coreファイルをサポートするシステムでは、Emacsはオプションで@dfn{コアダンプ(core
dump)}を生成します。コアダンプはクラッシュ前のプログラムの状態に関する多くのデータを含むファイルで、通常GDBのようなデバッガーにロードして調べられます。多くのプラットフォームでは、コアダンプはデフォルトで無効になっているので、(たとえばシェルのスタートアップスクリプトで)シェルコマンド@samp{ulimit
-c unlimited}を実行して、明示的に有効にしなければなりません。

@node After a Crash
@subsection クラッシュ後のリカバリー
@cindex recovering crashed session

  Emacs、またはコンピューターがクラッシュした場合、クラッシュしたとき編集していたファイルを、自動保存ファイルからリカバリーすることができます。これを行なうには、再びEmacsを開始して、コマンド@kbd{M-x
recover-session}とタイプしてください。

  このコマンドはm最初に中断されたセッションのファイルを、ファイルの日付とともにリストするバッファーを表示します。そこからリカバリーするファイルを、選択しなければなりません。通常リカバリーしたいファイルは、一番最近のセッションでしょう。選択したファイルにポイントを移動して、@kbd{C-c
C-c}とタイプしてください。

  その後@code{recover-session}は、そのセッション中に編集していた各ファイルについて、検討を行ないます。そのようなファイルそれぞれについて、そのファイルをリカバリーするか尋ねるのです。あるファイルにたいして@kbd{y}と応えると、コマンドはファイルとファイルの自動保存ファイルの日付を表示して、再度そのファイルをリカバリーするか尋ねます。この2回目の質問にたいして同意するには、@kbd{yes}と応えなければなりません。@kbd{yes}と応えた場合、Emacsはそのファイルをvisitしますが、テキストは自動保存ファイルから取得します。

  @code{recover-session}が終了すると、リカバリーを選択したファイルがEmacsバッファーに表示されます。そこでファイルを保存する必要があります。それらを保存することだけが、そのファイル自身を更新するのです。

  ファイルに関連付けられていないバッファーをリカバリーしたいときや、自動保存が重要な更新を記録するほど最新でなかった場合、最後の手段として ---
コアダンプが保存されていて、Emacsの実行ファイルからデバッグシンボルがストリップされていないという条件の元に ---
コアダンプからそれらを取得するために、GDB(GNUデバッガー)で@file{etc/emacs-buffer.gdb}スクリプトを使用することができます。

  コアダンプを入手したら、すぐに@file{core.emacs}のような別の名前にリネームします。これにより、他のクラッシュによるコアダンプの上書きを防ぎます。

  このスクリプトを使用するには、Emacs実行ファイル名とコアダンプのファイル名を、@samp{gdb /usr/bin/emacs
core.emacs}のように指定します。@code{(gdb)}プロンプトで、@samp{source
/usr/src/emacs/etc/emacs-buffer.gdb}としてリカバリースクリプトをロードします。それから利用可能なバッファーを見るために、コマンド@code{ybuffer-list}とタイプします。これは各バッファーにたいして、バッファー番号をリストします。バッファーを保存するには、@code{ysave-buffer}を使用します。ここでバッファー番号とそのバッファーを書き込むファイル名を指定します。すでに存在するファイル名を使用するべきではありません。ファイルがすでに存在する場合、このスクリプトはそのファイルの古い内容のバックアップを作成しません。

@node Emergency Escape
@subsection 緊急エスケープ
@cindex emergency escape

  テキスト端末では、1回目の@kbd{C-g}にたいしてEmacsが実際に反応してquitする前に、2回目の@kbd{C-g}をタイプすると、@dfn{緊急エスケープ(emergency
escape)}が、Emacsを即座にサスペンドします。これにより、どんなにひどくハングしていても、常にGNU
Emacsを抜け出すことができます。物事が正しく処理されている場合、Emacsは最初の@kbd{C-g}を素早く認識・処理するので。2回目の@kbd{C-g}は緊急エスケープを引き起こしません。しかし何らかの問題が、Emacsが最初の@kbd{C-g}を処理するのを妨げる場合、2回目の@kbd{C-g}でシェルに戻ります。

  緊急エスケープによるサスペンドからEmacsを再開する場合、サスペンド前に行なっていた何かに戻る前に、Emacsは以下の2つの質問をします:

@example
Auto-save? (y or n)
Abort (and dump core)? (y or n)
@end example

@noindent
質問に応えるには、それぞれにたいして@kbd{y}または@kbd{n}の後に、@key{RET}をタイプします。

  @samp{Auto-save?}にたいして@kbd{y}と応えると、自動保存が有効なすべての編集されたバッファーの自動保存を、即座に行ないます。@kbd{n}と応えると、これをスキップします。

  @samp{Abort (and dump
core)?}にたいして@kbd{y}と応えると、Emacsはクラッシュしてコアダンプします。これは専門家(wizard)が、なぜEmacsが最初の@kbd{C-g}でquitしなかったかを見つけ出すことを可能にします。コアダンプの後、実行は継続されません。

  この質問に@kbd{n}と応えた場合、Emacsは実行を再開します。運がよければ、Emacsは最終的にquit要求を行なうでしょう。そうでない場合、連続して@kbd{C-g}をタイプして、緊急エスケープを再度呼び出します。

  実際はEmacsがハングしているのではなく、遅いだけの場合、本当に意味するところを意図せずに、2連@kbd{C-g}の機能を呼び出してしまうかもしれません。この場合は、2つの質問の両方に@kbd{n}を応えれば、前の状態に戻ることができます。やがて要求したquitが行なわれるでしょう。

  緊急エスケープはテキスト端末だけでアクティブになっています。グラフィカルなディスプレーでは、マウスを使用してEmacsをkillしたり、他のプログラムに切り替えることができます。

  MS-DOSでは緊急エスケープを発生させるために、@kbd{C-@key{Break}}を2回タイプしなければなりません ---
しかしシステムコールがハングしたり、EmacsがCコードのタイトなループにハマっているときは機能しないケースがあります。

@node Bugs
@section バグの報告

@cindex bugs
  Emacsでバグを見つけたと思ったときは、それを報告してください。それをfixすることは約束できませんし、それがバグであると常に認める訳ではありませんが、もちろんそれについて知りたいのです。追加したいと考える機能についても、同じことが言えます。以下のセクションは、有効なバグレポートを作成する助けとなるでしょう。

@menu
* Known Problems::           既知の問題とバグについて読む方法。
* Criteria: Bug Criteria.    本当にバグを見つけたのか?
* Understanding Bug Reporting::  バグを報告する効果的な方法。
* Checklist::                良いバグレポートのために従うべきステップ。
* Sending Patches::          GNU Emacsにパッチを送る方法。
@end menu

@node Known Problems
@subsection 既存のバグレポートの既知の問題を読む

  バグを報告する前に、少しでも可能なら、それが既知のものか確認してください。実際には、それがもっと後のEmacsリリースや、Emacsの開発バージョンですでにfixされているかもしれません。以下は、既知の問題について読むことができる、主な場所のリストです:

@itemize
@item
@file{etc/PROBLEMS}ファイル。@kbd{C-h
C-p}とタイプして読むことができます。このファイルには、Emacsをコンパイル、インストール、実行するときに出会う、既知の問題の詳しいリストが含まれています。次善策や解決策の提案も、多くあります。

@item
追加のユーザーレベルの問題のいくつかは、@ref{Bugs and problems, , Bugs and problems, efaq, GNU
Emacs FAQ}でも見ることができます。

@cindex bug tracker
@item
@url{http://debbugs.gnu.org}のGNU Bug
Tracker。Emacsのバグは@samp{emacs}パッケージの下のトラッカーにファイルされています。トラッカーは、各バグの状態、最初のバグレポート、バグ報告者とEmacs開発者によるフォローアップメッセージについて情報を記録します。subject、severity、その他の条件でバグを検索できます。

@cindex debbugs package
ウェブページでバグトラッカーを閲覧するかわりに、@code{debbugs}パッケージを使用して、それをEmacsから閲覧できます。このパッケージはパッケージメニュー(@ref{Packages}を参照してください)を通じてダウンロードできます。このパッケージは、バグをリストするコマンド@kbd{M-x
debbugs-gnu}、特定のバグを検索する@kbd{M-x
debbugs-gnu-search}を提供します。Emacsメンテナーにより適用されるユーザータグは、@kbd{M-x
debbugs-gnu-usertags}で表示されます。

@item
@samp{bug-gnu-emacs}メーリングリスト(ニュースグループ@samp{gnu.emacs.bug}も利用可能)。リストのアーカイブは@url{http://lists.gnu.org/mailman/listinfo/bug-gnu-emacs}で見ることができます。このリストはバグトラッカーに送られたEmacsバグレポートとドローアップメッセージの、``mirror''として機能します。これにはバグトラッカーが導入される前(2008年以前)の古いバグレポートも含まれています。

もし望むなら、メーリングリストに登録できます。このリストの目的はEmacsメンテナーにバグと機能リクエストの情報を提供するためのもので、報告には大量のデータが含まれるかもしれないことに注意してください。購読者はこれについて不満を言うべきではありません。

@item
@samp{emacs-pretest-bug}メーリングリスト。このリストは今は使用されておらず、主に歴史的な興味のためのものです。一時は(たとえばまだリリースされていない)Emacs開発バージョンのために使用されていました。2003年から2007年中頃までのアーカイブは、@url{http://lists.gnu.org/archive/html/emacs-pretest-bug/}で見ることができます。現在は@samp{bug-gnu-emacs}にたいするエイリアスです。

@item
@samp{emacs-devel}メーリングリスト。このメーリングリストにバグを報告する人がときどきいます。しかしこのリストの主な目的は違うので、バグレポートはバグリストに送るほうがよいでしょう。バグを報告する前に、この一覧を読んだことに感謝を感じることはありません。

@end itemize


@node Bug Criteria
@subsection バグがあったとき
@cindex bug criteria
@cindex what constitutes an Emacs bug

  Emacsが不正なメモリー位置にアクセスする場合(``segmentation fault'')、または(``disk
full''のようなメッセージではなく)プログラムに問題があることを示す、オペレーティングシステムのエラーメッセージとともに終了する場合、それは確実にバグです。

  Emacsがバッファーの内容を正しく対応して表示しないとき、それはバグです。しかしバッファーのナローイング(@ref{Narrowing}を参照してください)チェックするべきです。これはバッファーの一部を隠して、表示される方法を変更できるので、バグではありません。

  コマンドが永久に完了しないなら、それはバグですが、本当にEmacsのせいか確認しなくてはなりません。コマンドの中には単に長時間かかるものがいくつかあります。@kbd{C-g}
(MS-DOSでは@kbd{C-@key{Break}})をタイプしてから、@kbd{C-h
l}で、Emacsが受け取った入力が、あなたがタイプしようと意図したものなのか確認します。その入力が、あなたが素早く処理されるべきだと@emph{わかっている}ものだった場合は、バグを報告してください。そのコマンドが長時間かかるものか判らない場合は、マニュアルを調べるか、協力してくれる人に尋ねてください。

  あなたの親しんでいるコマンドが、コマンドの通常の定義が正当なのに、Emacsのエラーメッセージを表示する場合、それはおそらくバグです。

  コマンドが間違ったことを行なうなら、それはバグです。しかしそのコマンドが何を行なうべきか確実に知っているか確認してください。そのコマンドに詳しくない場合、コマンドは実際は正しく動いているのでしょう。疑うなら、コマンドのドキュメント(@ref{Name
Help}を参照してください)を参照してください。

  あるコマンドの意図された定義が、それを編集するための最良の定義ではないこともあります。これはとても重要な問題の一種ですが、判断の問題でもあります。いくつかの既存の機能にたいする無知から、そのような決定を行なうのは簡単でもあります。通常の方法でドキュメントをチェックして、それを理解したと確信し、あなたがやりたいことが不可能だと確実に判るまでは、そのような問題にたいして不満を言わないのが、おそらく最良です。他のEmacsユーザーにも尋ねてみましょう。マニュアルを注意深く読んだ後でも、そのコマンドが何を想定しているか確信がもてないときは、不明解な単語をindex(索引)やglossary(用語集)でチェックしましょう。

  注意深くマニュアルを読んだ後でも、そのコマンドが何を行なうべきか判らないとき、それは報告すべきマニュアルのバグであることを示します。Emacsのエクスパートでない人
--- あなたを含めて --- にたいして、すべてを明解にするのがマニュアルの役目です。プログラムのバグと同様に、ドキュメントのバグレポートは重要です。

  関数や変数のビルトインドキュメントがマニュアルと異なる場合、どちらか一方が間違っていなければならないので、これはバグです。

@node Understanding Bug Reporting
@subsection バグレポートの理解
@cindex bug reporting
@cindex report an Emacs bug, how to

@findex emacs-version
  バグがあると判断したときは、それを報告すること、そして有用な方法で報告することが重要です。もっとも有用なのは、Emacsを起動するシェルコマンドから、問題が発生するまでに、何のコマンドをタイプしたかの正確な記述です。

  バグレポートのもっとも重要な原理は、@emph{事実}を報告することです。仮定や口頭の説明は、詳細な生データの代替にはなりません。事実の報告は簡単ですが、多くの人は事実のかわりに仮定の説明をしようと懸命に努め、それを報告するのです。その説明がEmacsが実装されている方法にたいする仮定にもとづく場合、それらは使い道がありません。その一方で事実の欠落により、わたしたちはバグについての実際の情報を得られないでしょう。実際に問題を@emph{デバッグ}して、推定を超える説明を報告したい場合、それは有用です
--- しかし、どうか生の事実も同様に含めてください。

  たとえば、@kbd{C-x C-f /glorp/baz.ugh
@key{RET}}とタイプして、ファイルをvisitしたとき、そのファイルが偶然大きい(とあなたは知っている)ファイルで、Emacsが@samp{I
feel pretty
today}と表示したとします。バグレポートにはすべての情報が必要になります。あなたは問題がファイルのサイズにあると仮定して、``大きなファイルをvisitしたら、Emacsが@samp{I
feel pretty today}と表示します''、などと報告すべきではありません。これはわたしたちが``推測説明(guessing
explanations)''と呼ぶものです。ファイル名に@samp{z}があるという事実が、問題の原因かもしれません。もしそうなら、あなたの報告を受け取ったとき、わたしたちは``大きなファイル''で問題の再現を試み、それらのファイル名にはおそらく@samp{z}が含まれておらず、問題を確認できないでしょう。名前に@samp{z}が含まれるファイルをvisitしてみるべきだと、推測できる方法はありません。

  @kbd{C-x
C-f}のではなく、``ファイルをvisit''とさえ言うべきではありません。同様にテキストを入力する方法では、``その行に3文字あるとき''ではなく、``@kbd{@key{RET}
A B C @key{RET} C-p}とタイプした後''と書いてください。

  可能なら、すぐにバグを再現するために@command{emacs -Q}(Emacsは初期のカスタマイズなしで開始されます。@ref{Initial
Options}を参照してください)でEmacsを呼び出して、バグを発生させるステップを繰り返してみてください。この方法でバグを再現できたら、あなたの個人的なカスタマイズをバグから除外できます。バグレポートは、Emacsを@command{emacs
-Q}で開始したことから始まり、バグを再現させる正確な一連のステップを続けるべきです。可能ならバグを再現するのに必要な、正確なファイル内容を報告してください。

  @command{emacs
-Q}では再現できないバグもいくつかあります。結局は再現するのが難しいバグもあります。そのような場合、何を行なったかを報告すべきです ---
が、前述したように、どうか最初にバグを発生させた生の事実を固持してください。

  報告したい複数の問題がある場合は、どうかそれらを個別のバグとしてそれぞれ報告してください。

@node Checklist
@subsection バグレポートのためのチェックリスト
@cindex checklist before reporting a bug
@cindex bug reporting, checklist

  バグを報告する前に、まずその問題がすでに報告されていないか、確認を試みてください(@ref{Known Problems}を参照してください)。

もし可能なら、その問題がすでにfixされていないか、最新リリース版のEmacsも試してみてください。同様に、最新の開発版を試してみるのもよいでしょう。これがある人にとっては簡単でないことは認識しているので、バグを報告する前に、絶対にこれを行なわなければならないと思わないでください。

@findex report-emacs-bug
  Emacsでバグレポートを書くベストな方法は、コマンド@kbd{M-x
report-emacs-bug}を使用する方法です。これはメールバッファー(@ref{Sending
Mail}を参照してください)をセットアップして、自動的に@emph{いくつかの}重要な情報を挿入します。しかし、すべての必要な情報は提供できません。だから以下のガイドラインを読んで、それに従うべきです。そうすればメッセージを送る前に、他の重大な情報を手で入力できます。@kbd{M-x
report-emacs-bug}によって挿入されたいくつかの情報は、適切ではないと感じるかもしれませんが、完全に確信があるのでなければそれを残してください。そうすれば開発者たちがそれを判断できます。

レポートを記述し終えたら、@kbd{C-c C-c}とタイプすると、それはEmacsメンテナー
@ifnothtml
@email{bug-gnu-emacs@@gnu.org}に送られます
@end ifnothtml
@ifhtml
@url{http://lists.gnu.org/mailman/listinfo/bug-gnu-emacs,
bug-gnu-emacs}に送られます
@end ifhtml
(新しい機能や改善を提案したいときも、同じアドレスを使用します)。Emacsの中からメールを送れない場合、バグレポートのテキストを通常使用しているメールクライアントにコピーして(システムがサポートしている場合は、@kbd{C-c
M-i}でEmacsにそれを行なわせることができます)、そのアドレスに送信できます。または、そのアドレスに問題を説明する簡単なメールを送ることもできます。

レポートは@samp{bug-gnu-emacs}メーリングリストに送られ、@url{http://debbugs.gnu.org}のGNU Bug
Trackerに保管されます。報告について、より詳細な情報を尋ねる必要がある場合のために、どうか有効な返信用アドレスを含めてください。提出されたレポートは調停されるので、レポートが見られるようになるまで遅れが生じることもあります。

バグを報告するためにGnu Bug
Trackerがどのように機能するか知る必要はありませんが、もし望むなら、トラッカーのオンラインドキュメントで、使用できるさまざま機能を見ることができます。

@samp{bug-gnu-emacs}メーリングリストに送られたすべてのメールは、@samp{gnu.emacs.bug}ニュースグループにもゲートウェイされます。この逆も真ですが、バグレポート(または返信)をニュースグループにポストしないでください。これにより、さらに情報を尋ねるためにあなたに連絡するのが困難になるのと、それがバグトラッカーと充分に統合されていないからです。

データが500,000バイトを超える場合は、どうかそれを直接レポートに含めないでください。要求されたら送るという提案に留めるか、データをFTPで利用可能にしてその場所を知らせてください。

  メンテナーがバグを詳細に調べられるように、レポートには以下の事項を含めるべきです:

@itemize @bullet
@item
Emacsのバージョン番号。これがないと、GNU Emacsのカレントバージョンで,
バグを探す意義があるかを知ることができません。

この情報は、@kbd{M-x
report-emacs-bug}により自動的にレポートに含まれますが、レポートでこのコマンドを使用しない場合は、@kbd{M-x
emacs-version @key{RET}}とタイプして、バージョン番号を取得できます。このコマンドが機能しない場合、たぶんあなたはGNU
Emacsではない他の何かを使っているので、どこか他のところにそのバグを報告する必要があるでしょう。

@item
使用している機種のタイプ、およびオペレーティングシステム名とバージョン番号(繰り返しになりますが、これらは@kbd{M-x
report-emacs-bug}で自動的にレポートに含まれます)。@kbd{M-x emacs-version
@key{RET}}もこの情報を提供します。@file{*Messages*}バッファーからコマンドの出力をコピーすれば、すべてを正確に取得できます。

@item
Emacsをインストールしたとき、@code{configure}に与えたオプション(@kbd{M-x
report-emacs-bug}により自動的にレポートに含まれます)。

@item
Emacsのソースにたいして行なった変更の完全なリスト(わたしたちには、変更されたEmacsのバグを詳細に調べる時間はないでしょう。しかし変更を行なっていて、それをわたしたちに告げないとしたら、それはわたしたちを野性のダチョウ狩りに送り出すようなものです)。

これらの変更について正確に記述してください。英語による説明では充分ではありません。それらにたいするコンテキストdiffも送ってください。

独自のファイル追加や、他の機種へのポートも、ソースの変更です。

@item
GNU Emacsの標準的なインストール手順からの、その他あらゆる逸脱の詳細。

@item
バグを再現するのに必要なファイルの完全なテキスト。

  ファイルをvisitせずに問題を発生させる方法を説明できるなら、ぜひそうしてください。これによりデバッグがとても簡単になります。ファイルが必要な場合、わたしたちがファイルの正確な内容を見られるよう確実にしてください。たとえば、行末にスペースがあるか、バッファーの最終行の後に改行があるかが問題となる場合があります(最終行が終端されているかどうかを心配すべき理由はないかもしれませんが、それがバグだと報告することを試みてください)。

@item
バグを再現するためにタイプする必要がある、正確なコマンド。少しでも可能なら、@samp{-Q}オプション(@ref{Initial
Options}を参照してください)でEmacsを開始したときからの、完全なレシピを送ってください。このオプションはあなたの個人的なカスタマイズをバイパスします。

@findex open-dribble-file
@cindex dribble file
@cindex logging keystrokes
Emacsへの入力を正確に記録する方法の1つとして、それをdribbleファイルに書き込む方法があります。このファイルを開始するには、@kbd{M-x
open-dribble-file
@key{RET}}コマンドを使用します。このコマンドからそのEmacsプロセスがkillされるまで、Emacsはすべての入力を指定されたdribbleファイルにコピーします。機密情報(パスワードなど)は、dribbleファイルへの記録を終了させることに注意してください。

@item
@findex open-termscript
@cindex termscript file
@cindex @env{TERM} environment variable
表示のバグである可能性がある場合は、端末タイプ(環境変数@env{TERM}の値)、その端末にたいする@file{/etc/termcap}の完全なtermcapエントリー(このファイルはすべての機種で同じではありません)、Emacsが実際に端末に送った出力。

端末出力を収集する方法は、以下のLisp式

@example
(open-termscript "~/termscript")
@end example

@noindent
を、Emacs開始直後に、@kbd{M-:}を使用するか、@file{*scratch*}バッファーで実行します。その後Emacsプロセスがkillされるまで、Emacsはすべての端末出力を、指定されたtermscriptファイルにもコピーします。Emacs開始時にその問題が発生する場合は、この式をEmacs初期化ファイルに記述すれば、Emacsが最初にスクリーンを表示するときに、termscriptファイルもオープンされます。

警告: バグをシミュレートする端末タイプへのアクセスなしに、端末依存バグをfixするのは、しばしば困難で、不可能なときもあります。

@item
非@acronym{ASCII}または国際化されたテキストと関連性がある場合は、Emacsを開始したときのlocale。GNU/LinuxとUnixシステム、またはBashのようなPosixスタイルのシェルを使用している場合、以下のシェルコマンドを使用して関連する値を見ることができます:

@smallexample
echo LC_ALL=$LC_ALL LC_COLLATE=$LC_COLLATE LC_CTYPE=$LC_CTYPE \
  LC_MESSAGES=$LC_MESSAGES LC_TIME=$LC_TIME LANG=$LANG
@end smallexample

別の方法として、システムにそれがある場合は、GNU/LinuxおよびUnixコマンドを使用して、localeセッティングを表示できます。

@kbd{M-!}コマンドを使用してEmacsからこれらのコマンドを実行して、@file{*Messages*}バッファーからコマンドの出力をバグレポートにコピーできます。かわりに@kbd{M-x
getenv @key{RET} LC_ALL
@key{RET}}とタイプすると、@code{LC_ALL}の値をエコーエリアに表示するので、@file{*Messages*}バッファーからこの出力をコピーすることもできます。

@item
あなたが間違いと主張する動作の説明。たとえば``Emacsプロセスが致命的なシグナルを受け取った''とか``結果のテキストは以下だが、これは間違いだと思う''など。

もちろん、Emacsが致命的なシグナルを受け取るというバグなら、見逃すことはないでしょう。しかし、そのバグが正しくないテキストの場合、メンテナーは何が間違っているか気づかないかもしれません。なぜそのような危険を放置するのですか?

あなたが遭遇した問題が致命的なシグナルの場合でも、明示的にそれを告げるべきです。何か奇妙なこと ---
たとえばあなたのソースコピーの同期がとれていない、またはあなたのシステムのCライブラリーにバグがある(これはあり得ます) ---
が起こっているとしましょう。あなたのコピーはクラッシュするかもしれませんが、私たちのコピーはクラッシュしないでしょう。あなたがクラッシュすることを@emph{告げて}いれば、わたしたちのEmacsはクラッシュしないので、バグはなかったとわたしたちは言うことができます。クラッシュすることを告げていない場合、わたしたちはバグがあるかどうか知ることができません
--- わたしたちの観察から、なんらかの結論を描くことも不可能です。

@item
Emacs ManualやEmacs Lisp Reference
Manualが、実際のEmacsの振る舞いを記述できていない、またはテキストが分かりにくいといったバグの場合、間違いだと思うテキストをマニュアルからコピーしてください。そのセクションが小さければ、セクション名だけで充分です。

@item
バグの徴候がEmacsのエラーメッセージの場合、エラーメッセージの正確なテキストと、EmacsのLispプログラムがどのようにしてエラーに至ったかを示す、backtraceを報告するのが重要です。

エラーメッセージを正確に取得するには、それを@file{*Messages*}バッファーからバグレポートにコピーします。一部だけではなく、すべてをコピーしてください。

@findex toggle-debug-on-error
@pindex Edebug
エラーにたいするbacktraceを作成するには、エラーが発生する前に@kbd{M-x
toggle-debug-on-error}を使用します(つまり、このコマンドを与えた後で、バグを発生させなければなりません)。これはエラーによりbacktraceを表示するLispデバッガーを開始します。デバッガーのbacktraceをバグレポートにコピーしてください。EdebugパッケージでEmacs
Lispプログラムをデバッグする情報については、@ref{Edebug,, Edebug, elisp, the Emacs Lisp
Reference Manual}を参照してください。

このデバッガーの使用は、バグを再現する方法を知っているときだけ利用可能です。バグを再現できなければ、最低でもエラーメッセージ全体をコピーしてください。

@vindex debug-on-quit
Emacsが無限ループや、とても長い処理にハマっているように見えるとき、(変数@code{debug-on-quit}が非@code{nil}の場合は)@kbd{C-g}とタイプするとLispデバッガーを開始して、backtraceを表示します。このbacktraceは、そのような長いloopのデバッグにたいして有用なので、backtraceを生成できたら、バグレポートにコピーしてください。

@vindex debug-on-event
(@code{inhibit-quit}がセットされている等で)、@kbd{C-g}にEmacsが応答しない場合、Emacsの外から@code{debug-on-event}で指定されたシグナル(デフォルトはSIGUSR2)を送ることにより、デバッガーに入ることができます。

@item
Lispの世界にロードしたプログラム(初期化ファイルを含みます)をチェックしてください。任意の変数にたいするセットは、Emacsの機能に影響を与えるかもしれません。初期化ファイルをロードせずに、フレッシュな状態で開始されたEmacsでも、その問題が発生するか確認してください(@code{-Q}スイッチでEmacsを開始することによりinitファイルのロードを抑止できます)。それで問題が発生しなかったら、問題を発生させるためにLispの世界にロードしなければならないプログラムの、正確な内容を報告しなければなりません。

@item
その問題がinitファイルやEmacsの標準システムの一部ではない他のLispプログラムに依存する場合、最初にそれらのプログラムのメンテナーに苦情を訴えて、それがバグでないことを確認すべきです。彼らが機能すると思われる方法でEmacsを使用してバグを確認した後、彼らがそのバグを報告すべきです。

@item
GNU Emacsのソース中の何かについて言及したい場合、数行のコンテキストとともにそのコードの行を示してください。行番号だけを示すのは止めてください。

開発ソースの行番号と、あなたのソースの行番号は一致しません。行番号だけでは、あなたのバージョンでその行番号がどのコードをさすのか、メンテナーが判断するのに余分な作業を要しますし、それに確信をもつこともできません。

@item
GDBのようなCデバッガーからの追加情報は、そのマシンを利用できなくても問題を見つけることを可能にするかもしれません。GDBの使い方を知らなければ、どうかGDBマニュアルを読んでください
---
非常に長いという訳ではありませんし、GDBは簡単に使用できます。GDBマニュアルを含むGDBディストリビューションはオンライン形式で見つけることができ、ほとんどはEmacsディストリビューションと同じ場所で見つけることができます。GDBの下でEmacsを実行するためには、Emacsをコンパイルした場所の@file{src}サブディレクトリーに移動するべきです。カレントディレクトリーが@file{src}であることは重要です。GDBはこのディレクトリーの@file{.gdbinit}を読み込みます。

しかし、何がバグを引き起こしたかを示すような追加の情報を収集するときは、考える必要があります。

@cindex backtrace for bug reports
たとえば、多くの人はbacktraceだけを送って着ますが、これだけではとても有用とは言えません。引数つきのシンプルなbacktraceは、GNU
Emacsの中で何が起こっているかを少ししか伝えないことがしばしばです。なぜならbacktraceにリストされたほとんどの引数は、Lispオブジェクトへのポインターだからです。これらのポインターの数値は、何であれ意味をもちません。問題となるのはポインターが指すオブジェクトの内容(そして、その内容自身もポインターの場合がほとんどです)なのです。

@findex debug_print
有用な情報を提供するためには、Lispオブジェクトの値をLisp表記で示す必要があります。基底スタックの近傍のスタックフレームのいくつかで、Lispオブジェクト変数それぞれにたいしてこれを行ないます。どの変数がLispオブジェクトであるかはソースを調べます。なぜならデバッガーはそれらを整数と判断するからです。

Lisp構文で変数の値を表示するには、最初にその値をプリントして、それからLispオブジェクトをLisp構文でプリントするために、ユーザー定義のGDBコマンド@code{pr}を使用します(他のデバッガーを使用しなければならない場合、そのオブジェクトを引数として、関数@code{debug_print}を呼び出します)。@code{pr}コマンドはファイル@file{.gdbinit}で定義されていて、(コアダンプではなく)実行中のプロセスにたいしてデバッグするときだけ機能します。

LispエラーでEmacsを停止させてGDBに戻るには、@code{Fsignal}にブレークポイントを置きます。

実行中のLisp関数の短いリストのためには、GDBコマンド@code{xbacktrace}をタイプします。

ファイル@file{.gdbinit}では、データ型やLispオブジェクトの内容を調べるための、他のコマンドも定義されています。これらのコマンドの名前は@samp{x}で始まります。これらのコマンドは@code{pr}より低いレベルで動作するので、少し不便になりますが、コアダンプをデバッグしていたり、Emacsが致命的なシグナルを受け取ったときなど、@code{pr}が機能しないようなときでも、機能するでしょう。

@cindex debugging Emacs, tricks and techniques
Emacsのデバッグにたいする、より詳細なアドバイスと、他の有用なテクニックは、Emacsディストリビューションの、ファイル@file{etc/DEBUG}で利用可能です。そのファイルには、Emacsが応答しない問題を詳しく調べる手順も含まれています(多くの人はこれをEmacsが``ハング''したとみなしますが、実際はおそらく無限ループにハマっているのでしょう)。

インストールしたEmacsのファイル@file{etc/DEBUG}を探すには、変数@code{data-directory}に保管されたディレクトリー名を使用します。
@end itemize

以下はバグレポートには不要な事柄です:

@itemize @bullet
@item
バグを取り巻く状況の説明 --- これは再現可能なバグにたいしては必要ありません。

バグに遭遇したとき人は、入力ファイルを変えてバグが発生しなくなるか、影響がないかなどを詳しく調べるのに、多くの時間を費やすことがしばしばです。

これは大抵多くの時間がかかる割に、とても有用とは言えません。なぜならわたしたちがバグを探す方法は、ブレークポイントを設定したデバッガーの元で1つの例を実行することであり、一連の例から得られる推論ではないからです。追加の例を探すのを止めることにより、あなたも時間を節約できるでしょう。すぐにバグレポートを送って、編集作業に戻り、報告すべき他のバグを探す法がよいでしょう。

もちろんオリジナルの@emph{かわり}に、簡単な例を見つけることができたら、そちらのほうが便利です。出力中のエラーは簡単に見分けられますし、デバッガーでの実行も時間が短くなります

しかし単純化は必須ではありません、これを行なうことができなかったり、試す時間がない場合は、どうかオリジナルのテストケースでバグを報告してください。

@item
コアダンプファイル。

コアダンプによるデバッグは有用ですが、それはあなたのEmacs実行ファイルと、あなたのマシンだけで行なうことができます。したがってEmacsメンテナーにコアダンプを送るのは、有益ではないでしょう。何よりも、コアダンプをメールのバグレポートに含めないでください!
そのような巨大なメッセージは、すこぶる迷惑です。

@item
Emacsを実行したときのシステムコールトレース。

システムコールトレースは、ある特別な種類のデバッグにはとても有用ですが、有用な情報が少ない場合がほとんどです。したがって、クラッシュに関する情報を報告する@emph{一番}の方法は、システムコールトレースを送ることだと考えているように思える人が多いのは奇妙です。おそらくソースコードやデバッグシンボルがないプログラムをデバッグする経験がもたらす、習慣的なやり方なのでしょう。

ほとんどのプログラムでは、システムコールトレースより、backtraceのほうが、通常はずっとずっと参考になります。完全な情報を得るには、変数の値を表示して、それらを@code{pr}でLispオブジェクトとしてプリントすることによりbacktraceを補完すべきであるとはいえ、シンプルなbacktraceのほうが一般的により参考になります(上記参照)。

@item
バグにたいするパッチ。

バグにたいするパッチは、それが良いものなら有用です。しかし、そのパッチで充分だと思い込んで、テストケースのような、バグレポートに必要な他の情報を省略しないでください。わたしたちはそのパッチに問題を見つけて別の方法でfixすると判断するかもしれないし、結局はそれを理解できないかもしれません。わたしたちが、あなたがfixしようと試みているバグを理解できなければ、そしてなぜそのパッチが改善なのかを理解できなければ、私たちはそれを採用できません。

@ifnottex
わたしたちにパッチを理解させて、採用を簡単にするためのガイドラインについては、@ref{Sending Patches}を参照してください。
@end ifnottex

@item
バグが何か、何に依存するかについての推測。

そのような推測は通常間違っています。エキスパートでさえ、事実を見つけるために最初にデバッガーを使用しなければ、そのような事柄を正しく推測できないのです。
@end itemize

@node Sending Patches
@subsection GNU Emacsへのパッチの送付

@cindex sending patches for GNU Emacs
@cindex patches, sending
  GNU
Emacsを改善するためにバグfixを書きたいなら、それはとても助けになります。変更を送るとき、メンテナーがそれらを使うのが簡単になるように、どうか以下のガイドラインにしたがってください。これらのガイドラインにしたがわない場合でも、あなたの情報はまだ有用でしょうが、それを使用するのに余分な作業が必要になります。GNU
Emacsの保守は最良の状況でも多くの作業を要すので、わたしたちを助けるのにあなたがベストをすくさなければ、わたしたちはそれを維持できないのです。

@itemize @bullet
@item
その変更が何の問題をfixするのか、または何を改善するかの説明を一緒に送ってください。既存のバグにたいするfixについては、@samp{bug-gnu-emacs}リストの関連するディスカッションか、@url{http://debbugs.gnu.org}のGNU
Bug Trackerのバグエントリーに返信するのが最善でしょう。その変更が、なぜバグをfixするのか説明してください。

@item
あなたがfixしたと思っている問題にたいする、正しいバグレポートを常に含めてください。それを採用する前に、わたしたちはその変更が正しいと、私たち自身に納得させる必要があります。もしそれが正しくても、問題を再現する方法がない場合、それを理解する妨げになるでしょう。

@item
将来このソースを読む人の理解を助けとなるように、なぜこの変更が必要なのか、適切なコメントを含めてください。

@item
異なる理由にたいする変更を一緒に混ぜないでください。それらを@emph{個別}に送ってください。

異なる理由にたいして2つの変更を行なった場合、わたしたちをそれを一緒に採用したいとは思わないでしょう。1つだけを採用したいと思うかもしれません。それらを合わせて1つのdiffにして送った場合、それらを区別するために
--- 変更のどの部分がどの目的のためかを理解するために ---
余計な作業を行なう必要があります。これを行なう時間がない場合、わたしたちは変更全体を無視する必要があるかもしれません。

1つの変更を記述したら、その変更の説明と一緒にそれをすぐに送れば、2つの変更は混ざることはなくなり、それらを区別する余計な作業なしに、わたしたちはそれぞれを正しく判断することができます。

@item
1つの変更を終えたら、それをすぐに送ってください。ときどき人は多くの変更を累積して、すべて一緒に送るのがわたしたちの助けとなると考えます。上述したように、それは正にあなたにできる最悪のことです。

変更は個別に送るべきなので、すぐに送ることができるでしょう。これは、その変更が重要なものなら、それをすぐに採用するオプションをわたしたちに与えます。

@item
diffを作成するために、@samp{diff
-c}を使用してください。コンテキストなしのdiffは確実に採用が困難です。それ以上に調べるのが難しくなります。わたしたちは変更の採用を望ましいか判断するために、つねにパッチを調べなければなりません。Unidiffフォーマットはコンテキストなしのdiffより優れていますが、@samp{-c}のように簡単に読むことができません。

GNU diffがある場合、Cコードのdiffの作成には@samp{diff -c -F'^[_a-zA-Z0-9$]+
*('}を使用してください。これは変更のある関数名を表示します。

@item
どちらが古いバージョンで、どちらが新しいバージョンか、あいまいになるのを避けてください。どうかdiffの第1引数に古いバージョン、2番目の引数に新しいバージョンを指定してください。そして一方のバージョンにたいして、それが古いバージョンなのか、変更した新しいバージョンなのかを示す名前をつけてください。

@item
あなたの変更にたいする、変更ログ(ChangeLog)のエントリーを記述してください。それにより、わたしたちがそれを記述するために余計な作業をしなくてすみ、あなたが行なった変更をわたしたちが理解する助けにもなります。

変更された場所を示すのが、変更ログの目的です。したがって変更した関数について、具体的である必要があります。大きな関数では、関数のどこを変更したか示すのが、助けになる場合が多々あります。

それとは逆に、変更箇所を示せば、変更ログで変更目的の説明をする必要はありません。したがって、新しい関数を追加した場合、必要なのはそれが新しいということを示すだけです。変更目的の説明が必要だと感じたら、多分その通りなのでしょう、がコードのコメントにその説明を記述してください。変更目的はそこに記述されているほうが、より有用です。

どのような種類の情報を記述するかを見るために、最近のコミットにたいする変更ログエントリーを見て、わたしたちが使用しているスタイルを学んでください。@ref{Change
Log}を参照してください。

@item
fixを記述するときは、わたしたちが他のシステムを壊すような変更は採用できないということを、念頭に置いてください。あなたの変更が、ほかのタイプのシステムでコンパイルされた場合の影響について、考えてください。

一般的には改善となる@emph{かもしれない}が、そう確信するのは難しいようなfixを送る人が、ときどきいます。そのような変更を採用するのは、わたしたちがそれをとても慎重に調べなければならないので、難しくなります。もちろん、その変更が正しい理由の説明は、わたしたちを納得させる助けになります。

一番安全な変更は、特定の機種の設定ファイルにたいする変更です。これらの変更は、新しいバグを他の機種に作成しないので、安全です。

インストールの安全性が明確な形式でパッチをデザインして、わたしたちの作業量を、良い状態に保つ助けとなってください。
@end itemize

@c FIXME: Include the node above?
@node Contributing
@section Emacs開発への貢献
@cindex contributing to Emacs

Emacsを改善する作業をしたい場合は、
@ifnothtml
@email{emacs-devel@@gnu.org}のメンテナーに連絡してください。
@end ifnothtml
@ifhtml
@url{http://lists.gnu.org/mailman/listinfo/emacs-devel,
emacs-develメーリングリスト}のメンテナーに連絡してください。
@end ifhtml
提案されたプロジェクトを尋ねたり、あなたのアイデアを提案することができます。

すでに改善を記述したことがある場合は、それについて教えてください。まだ作業を開始していなければ、作業を開始する前に、
@ifnothtml
@email{emacs-devel@@gnu.org}
@end ifnothtml
@ifhtml
@url{http://lists.gnu.org/mailman/listinfo/emacs-devel, emacs-devel}
@end ifhtml
に連絡をとるのが有益です。Emacsの他の部分にたいして、あなたの拡張がより適合する方法を提案することが可能かもしれません。

Emacsの開発バージョンは、開発者グループにより活発にメンテされている、レポジトリーからダウンロードできます。詳細についてはEmacsプロジェクトのページ@url{http://savannah.gnu.org/projects/emacs/}を参照してください。

貢献する方法についての情報は、
@ifset WWW_GNU_ORG
@ifhtml
@url{http://gnu.org/software/emacs/CONTRIBUTE, etc/CONTRIBUTE}を参照してください。
@end ifhtml
@ifnothtml
@file{Emacsディストリビューションの、etc/CONTRIBUTE}
@end ifnothtml
@end ifset
@ifclear WWW_GNU_ORG
@file{Emacsディストリビューションの、etc/CONTRIBUTE}
@end ifclear
ファイルを参照してください。

@node Service
@section GNU Emacsにたいして助けを得る方法
@cindex help in using Emacs
@cindex help-gnu-emacs mailing list
@cindex gnu.emacs.help newsgroup

インストール、使用方法、またはGNU Emacsの変更について助言を必要とする場合は、それを探す2つの方法があります:

@itemize @bullet
@item
メッセージを
@ifnothtml
メーリングリスト@email{help-gnu-emacs@@gnu.org}に送るか、
@end ifnothtml
@ifhtml
@url{http://lists.gnu.org/mailman/listinfo/help-gnu-emacs,
help-gnu-emacsメーリングリスト}に送るか、
@end ifhtml
あなたの要求をニュースグループ@code{gnu.emacs.help}にポストしてください(このメーリングリストとニュースグループは相互接続しているので、どちらを使っても問題ありません)。

@item
手数料を徴収して助言してくれる人物を、@uref{http://www.fsf.org/resources/service/, service
directory}で探してください。
@end itemize

@ifnottex
@lowersections
@end ifnottex
