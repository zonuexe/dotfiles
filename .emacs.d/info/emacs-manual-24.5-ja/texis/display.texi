@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c This is part of the Emacs manual.
@c Copyright (C) 1985-1987, 1993-1995, 1997, 2000-2015 Free Software
@c Foundation, Inc.

@c See file emacs.texi for copying conditions.
@node Display
@chapter ディスプレーの制御

  ウィンドウに入りきらない大きなバッファーでは、Emacsはその一部しか表示できません。このチャプターでは、見たい部分のテキストを指定するコマンドや変数と、どのようにしてテキストが表示されるかを説明します。

@menu
* Scrolling::                ウィンドウのテキストを上下に移動させるコマンド。
* Recentering::              カレント行を中央にするスクロールコマンド。
* Auto Scrolling::           必要なときテキストをスクロールして再表示する。
* Horizontal Scrolling::     ウィンドウの左右にテキストを移動させる。
* Narrowing::                表示を制限してバッファーの一部を編集する。
* View Mode::                読み取り専用バッファーの表示。
* Follow Mode::              Followモードで2つのウィンドウを1つとしてスクロールさせる。
* Faces::                    フェイスを使って表示スタイルを変更する方法。
* Colors::                   フェイスのカラーを指定する。
* Standard Faces::           主要な既定のフェイス。
* Text Scale::               バッファーのテキストサイズの拡大と縮小。
* Font Lock::                フェイスを使って文法をハイライトするマイナーモード。
* Highlight Interactively::  Emacsにハイライトするテキストを指示する。
* Fringes::                  ウィンドウフリンジの有効と無効。
* Displaying Boundaries::    バッファーの先頭と最後を表示する。
* Useless Whitespace::       行末の不要な空白文字の表示。
* Selective Display::        インデントの大きな行を隠す。
* Optional Mode Line::       モードラインの表示機能のオプション。
* Text Display::             テキスト文字が通常表示される方法。
* Cursor Display::           カーソル表示の機能。
* Line Truncation::          複数のスクリーン行で継続表示させずにスクリーン幅に行を切り詰める。
* Visual Line Mode::         単語の折り返しとスクリーン行にもとづく編集。
* Display Custom::           ディスプレーをカスタマイズする変数の情報。
@end menu

@node Scrolling
@section スクロール
@cindex scrolling

  ウィンドウがバッファーのすべてのテキストを表示するには小さい場合、その一部だけが表示されます。@dfn{スクロール}コマンドは、バッファーで表示される部分を変更します。

  ``前方(forward)''または``上(up)''へのスクロールは、ウィンドウに表示される部分を先に進めます。これはウィンドウに表示されるバッファーのテキストを、上に移動させるのと同じです。``後方(backward)''または``下(down)''へのスクロールは、ウィンドウに表示される部分を前に戻します。これはウィンドウに表示されるバッファーのテキストを下に移動させます。

  Emacsでの``up''と``down''は、ウィンドウでテキストが移動する方向に基づいており、テキストにたいしてウィンドウが移動する方向では@emph{ありません}。この用語は現在の``scrolling
up''や``scrolling
down''が広まる前に、Emacsで採用されました。そのため@key{PageDown}は、Emacs的には``上(up)''にスクロールするという、奇妙な結果となりました。

  ウィンドウに表示されているバッファー部分には、常にポイントが含まれています。もしウィンドウの下端か上端を越えてポイントを移動させると、ポイントを画面に表示させるために自動的にスクロールが発生します(@ref{Auto
Scrolling}を参照してください)。以下のコマンドで明示的にスクロールができます:

@table @kbd
@item C-v
@itemx @key{next}
@itemx @key{PageDown}
ウィンドウのほぼ全画面分、前方にスクロールします(@code{scroll-up-command})。
@item M-v
@itemx @key{prior}
@itemx @key{PageUp}
後方にスクロールします(@code{scroll-down-command})。
@end table

@kindex C-v
@kindex M-v
@kindex next
@kindex prior
@kindex PageDown
@kindex PageUp
@findex scroll-up-command
@findex scroll-down-command
  @kbd{C-v}
(@code{scroll-up-command})は、ウィンドウ全体の高さに近い量、前方にスクロールします。これにより下端の2行が上端になるようスクロールして、それに続く表示されていなかった行を表示します。ポイントが上端より上になってしまう場合、ウィンドウの新たな上端の行に移動します。The
@key{next}(または@key{PageDown})は、@kbd{C-v}と同じです。

  @kbd{M-v}
(@code{scroll-down-command})は、同様の方法で後方にスクロールします。@key{prior}(または@key{PageUp})は、@kbd{M-v}と同じです。

@vindex next-screen-context-lines
  スクロールコマンドでオーバーラップして表示される行数は、変数@code{next-screen-context-lines}で制御され、デフォルトは2です。数引数@var{n}を与えたときは、@var{n}行スクロールします。Emacsはポイントを変更しないよう試みるので、テキストとポイントは一緒に上または下に動きます。@kbd{C-v}に負の引数を与えると、@kbd{M-v}のように反対方向へスクロールします。

@vindex scroll-error-top-bottom
  デフォルトでは、ウィンドウがバッファーの先頭または最後に到達していて、これ以上スクロールできない場合、これらのコマンドは(beep音をならしたり画面をフラッシュして)エラーをシグナルします。変数@code{scroll-error-top-bottom}を@code{t}に変更すると、コマンドは可能な限り、つまりバッファーの先頭の文字または最後の文字にポイントを移動します。ポイントがすでにそこにあるときは、エラーをシグナルします。

@vindex scroll-preserve-screen-position
@cindex @code{scroll-command} property
  スクロールしたとき、ポイントが同じスクリーン位置に留まることを好むユーザーもいます。そうすれば同じスクリーンにスクロールして戻ったとき、ポイントが元の位置にあると便利だからです。この動作は変数@code{scroll-preserve-screen-position}を通じて利用可能です。変数の値が@code{t}のとき、スクロールコマンドによりポイントがウィンドウの外にでるような場合、Emacsはポイントを先頭行または最終行に移動させるのではなく、同じスクリーン位置にポイントを調整して、カーソルを維持します。その他の非@code{nil}値の場合、Emacsはスクロールコマンドによりポイントがウィンドウに残っている場合にも、この方法でポイントを調整します。この変数はこのセクションで説明するすべてのスクロールコマンド、同様にマウスホイールによるスクロール(@ref{Mouse
Commands}を参照してください)に影響を与えます。一般的にいうと、この変数は@code{scroll-command}プロパティが非@code{nil}のコマンドに影響を及ぼします。@ref{Property
Lists,,, elisp, The Emacs Lisp Reference Manual}を参照してください。

@vindex scroll-up
@vindex scroll-down
@findex scroll-up-line
@findex scroll-down-line
  コマンド@kbd{M-x scroll-up}および@kbd{M-x
scroll-down}は、@code{scroll-up-command}および@code{scroll-down-command}と同様に動作しますが、@code{scroll-error-top-bottom}を考慮しません。これらのコマンドは、Emacs
24以前ではスクロールアップおよびスクロールダウンのためのデフォルトでした。コマンド@kbd{M-x
scroll-up-line}および@kbd{M-x
scroll-down-line}は、現在のウィンドウを1行スクロールさせます。もしこれらのコマンドを使う場合は、それにキーバインドを割り当てたくなるでしょう(@ref{Init
Rebinding}を参照してください)。

@node Recentering
@section センタリング

@table @kbd
@item C-l
選択されているウィンドウで、現在行が中央になるようスクロールします。連続して呼び出すと、次は現在行が上端になり、その次は現在行が下端に、という順番で循環します。画面の再描画が行われる可能性があります(@code{recenter-top-bottom})。

@item M-x recenter
選択されているウィンドウで、現在行が中央になるようにスクロールします。画面の再描画が行われる可能性があります。

@item C-M-l
有用な情報が表示されるよう、発見的な手法でスクロールします(@code{reposition-window})。
@end table

@kindex C-l
@findex recenter-top-bottom
  @kbd{C-l}
(@code{recenter-top-bottom})コマンドは、選択されたウィンドウにたいして@dfn{センタリング(recenters)}をします。これにより現在のスクリーン行がウィンドウの中央、または中央に一番近い行になります。

  (@kbd{C-l
C-l})のように@kbd{C-l}を2回タイプすると、ポイントのある行が上端になるようにスクロールします。@kbd{C-l}を3回タイプするとポイントのある行が下端になるようにスクロールします。連続して@kbd{C-l}をタイプすることにより、上記の3つの位置を循環してスクロールできます。

@vindex recenter-positions
  リスト変数@code{recenter-positions}をカスタマイズすることにより、循環する順序を変更できます。リスト要素にはシンボル@code{top}、@code{middle}、@code{bottom}または数値を指定します。数値に整数を指定すると、現在行が指定したスクリーン行になるようスクロールします。数値に0.0から1.0の浮動小数点数は、ウィンドウの上端から現在行までを割合で指定します。デフォルトは@code{(middle
top
bottom)}で、これは上述した循環順序です。さらに変数@code{scroll-margin}を、0以外の値@var{n}に変更すると、@kbd{C-l}は常にウィンドウの上端または下端からスクリーン行で、@var{n}行を残してスクロールします(@ref{Auto
Scrolling}を参照してください)。

  @kbd{C-l}にプレフィクス引数を指定することもできます。@kbd{C-u
C-l}のようにプレフィクス引数だけを指定すると、単にポイントのある行を中央にします。正の引数@var{n}は、ポイントのある行がウィンドウの上端から@var{n}行目になるようにスクロールします。0を指定すると、ポイントのある行が上端になるようにスクロールします。負の引数@var{-n}は、ポイントのある行がウィンドウの下端から@var{n}行目になるようにスクロールします。引数を与えたときは、@kbd{C-l}は画面をクリアーせず、異なるスクリーン位置への循環もしません。

@vindex recenter-redisplay
  変数@code{recenter-redisplay}が非@code{nil}値の場合、@kbd{C-l}はスクリーンのクリアーと再描画を行います。特別な値@code{tty}(デフォルト)は、これをテキスト端末上のフレームだけに限定します。再描画はスクリーンが何らかの理由により文字化けしてしまったときなどに便利です(@ref{Screen
Garbled}を参照してください)。

@findex recenter
  より原始的なコマンド@kbd{M-x
recenter}は、@code{recenter-top-bottom}と同じように振る舞いますが、スクリーン位置を循環しません。

@kindex C-M-l
@findex reposition-window
  @kbd{C-M-l}
(@code{reposition-window})は、有用な情報がスクリーンに表示されるように、現在のウィンドウを発見的な手法によりスクロールします。たとえばLispファイルの場合、このコマンドは可能な限り現在のdefun全体がスクリーン上に表示されるよう試みます。

@node Auto Scrolling
@section 自動スクロール

@cindex automatic scrolling
  ポイントが表示されているテキスト部分から外に移動すると、Emacsは@dfn{自動スクロール(automatic
scrolling)}の処理を行います。通常自動スクロールは、ウィンドウの垂直方向の中央にポイントをセンタリングしますが、この振る舞いを変えるいくつかの方法があります。

@vindex scroll-conservatively
  @code{scroll-conservatively}に小さい数字@var{n}をセットすると、ポイントが少し(@var{n}行以下)スクリーンの外に出たら、Emacsはポイントがスクリーンに表示されるのに充分なだけスクロールします。これでもしポイントの表示に失敗した場合、Emacsはそのウィンドウの中央にポイント行が表示されるのに充分なだけのスクロールをします。@code{scroll-conservatively}に大きな数字(100より大)も数字をセットすると、どれだけポイントを移動させようと、自動スクロールはポイント行を中央にセンタリングしなくなります。Emacsはポイントが表示されるように常にテキストをスクロールします。ウィンドウの上端または下端かはスクロールの方向に依存します。デフォルトでは@code{scroll-conservatively}は@tie{}0で、これは常にポイント行がウィンドウの中央にセンタリングされることを意味します。

@vindex scroll-step
  自動スクロールを制御する他の方法は、変数@code{scroll-step}をカスタマイズすることです。この変数の値はポイントがスクリーンから外れたとき、何行を自動スクロールさせるかを決定します。その行数スクロールしてもポイントが表示されない場合、かわりにポイント行が中央にきます。デフォルト値は0で、スクロール後は常にポイント行が中央にきます。

@cindex aggressive scrolling
@vindex scroll-up-aggressively
@vindex scroll-down-aggressively
  自動コントロールを制御する3番目の方法は、変数@code{scroll-up-aggressively}と@code{scroll-down-aggressively}をカスタマイズすることで、これは直接スクロール後のポイントの垂直位置を指定します。@code{scroll-up-aggressively}の値には、@code{nil}(デフォルト)、または0から1までの浮動小数点数@var{f}を指定します。ポイントがウィンドウの下端を越えたとき(たとえば前方にスクロールしたとき)、Emacsはウィンドウの高さとウィンドウの下端からポイント行までの割合が、@var{f}になるようスクロールします。つまり@var{f}を大きくするとより積極的(aggressive)、つまり新しいテキストがより多く表示されることを意味します。デフォルト値@code{nil}は0.5と同じです。

  同様に@code{scroll-down-aggressively}は、ポイントがウィンドウの上端を越えたとき(たとえば後方にスクロールしたとき)の振る舞いを設定します。値にはスクロール後のウィンドウの上端からポイント行までのマージンを指定します。つまり@code{scroll-up-aggressively}を大きくすると、より積極的になります。

  変数@code{scroll-conservatively}、@code{scroll-step}、および@code{scroll-up-aggressively}と@code{scroll-down-aggressively}は、互いに矛盾する方法で自動スクロールを制御します。したがって自動スクロールをカスタマイズする場合は、2つ以上の手法を選ぶべきではありません。もし2つ以上の変数をカスタマイズする場合は、@code{scroll-conservatively}、次に@code{scroll-step}、そして最後に@code{scroll-up-aggressively}と@code{scroll-down-aggressively}という優先順でカスタマイズしてください。

@vindex scroll-margin
  変数@code{scroll-margin}は(たとえscroll-up-aggressivelyやscroll-down-aggressivelyに、上端または下端からのマージンがウィンドウにたいして占める割合より大きくなるような@var{f}を指定していても)、ポイントがウィンドウの上端または下端にどれだけ近づけるかを制限します。変数の値にはスクリーン行の行数です。もしポイントがウィンドウの上端または下端から指定した行数の位置にくると、Emacsは自動的にスクロールします。デフォルトでは@code{scroll-margin}は0です。

@node Horizontal Scrolling
@section 水平スクロール
@cindex horizontal scrolling

@vindex auto-hscroll-mode
  @dfn{水平スクロール(Horizontal
scrolling)}は、ウィンドウの行を右方向に移動させます。そのため左端の近くのテキストは表示されなくなります。ウィンドウのテキストが水平スクロールされると、テキスト行は折り返されるのではなく、切り詰め(truncated)られます。ウィンドウが切り詰められた行を表示しているとき、ポイントがスクリーンの左端か右端を越えて移動すると、Emacsは自動的に水平スクロールを行います。自動的な水平スクロールを無効にするには、変数@code{auto-hscroll-mode}に@code{nil}をセットしてください。また自動的な水平スクロールがオフになっている場合、ポイントがスクリーンの端を越えると、それを知らせるためにカーソルが表示されなくなることに注意してください(テキスト端末の場合カーソルは端に残されます)。

@vindex hscroll-margin
  変数@code{hscroll-margin}は、自動的なスクロールが起こる前に、ポイントがウィンドウの左端または右端に、どれだけ近づけるかを制御します。変数の値は列数で指定します。たとえば変数の値が5のときは、端から5列目にポイントが移動すると、水平スクロールが発生します。

@vindex hscroll-step
  変数@code{hscroll-step}はmポイントが端に近づきすぎたときに、何列スクロールするかを決定します。デフォルト値の0は、ポイントがウィンドウの中央になるようにスクロールされることを意味します。正の整数はスクロールされる列数を指定します。浮動小数点数は、スクロールされる量を、ウィンドウの幅にたいする割合で指定します。

  以下のコマンドで明示的に水平スクロールすることもできます:

@table @kbd
@item C-x <
現在のウィンドウのテキストを左にスクロールします(@code{scroll-left})。
@item C-x >
右にスクロールします(@code{scroll-right})。
@end table

@kindex C-x <
@kindex C-x >
@findex scroll-left
@findex scroll-right
  @kbd{C-x <}
(@code{scroll-left})は選択された、ウィンドウをウィンドウ幅から2列少ない列数、左にスクロール(いいかえればウィンドウのテキストは左に移動)します。数引数@var{n}を指定すると、@var{n}列スクロールします。

  テキストが左にスクロールされて、ポイントがウィンドウの左端を越えると、ポイントが表示されているテキストに戻るまで、カーソルはフリーズします。これは@code{auto-hscroll-mode}の設定とは独立しています(これはテキストを左にスクロールするときのウィンドウの右端での振る舞いだけに影響します)。

  @kbd{C-x >}
(@code{scroll-right})は、同様に右にスクロールします。ウィンドウが通常の表示(行の先頭がウィンドウの左端に表示されている状態)のときは、それ以上スクロールできないので何も起こりません。これは@w{@kbd{C-x
>}}の引数を正確に計算する必要がないことを意味します。充分に大きな引数を与えれば、通常の表示が復元されます。

  これらのコマンドでウィンドウを水平方向にスクロールすると、自動水平スクロールの下限値がセットされます。自動スクロールはウィンドウのスクロールを続けますが、前に@code{scroll-left}にセットされた値を越えて右にスクロールできなくなります。

@node Narrowing
@section ナローイング
@cindex widening
@cindex restriction
@cindex narrowing
@cindex accessible portion

  @dfn{ナローイング(Narrowing)}とはバッファーのある範囲にフォーカスを置き、他の部分を一時的にアクセス不能にすることを意味します。扱うことのできる範囲のことを、@dfn{アクセス可能範囲(accessible
portion)}と呼びます。ナローイングを取り消すと。バッファー全体に再びアクセスできるようになります。これを@dfn{ワイドニング(widening)}と呼びます。バッファーにたいして、ナローイングにより境界を設けることを、バッファーの@dfn{制限(restriction)}と呼びます。

  ナローイングにより、他の部分に気を取られずに、1つのサブルーチンやパラグラフに集中することが容易になります。ナローイングは、置換コマンドやキーボードマクロの繰り返しにより操作される範囲を制限するためにも使われます。

@table @kbd
@item C-x n n
ポイントとマークの間にナローイングします(@code{narrow-to-region})。
@item C-x n w
バッファー全体をワイドニングして、再びアクセス可能にします(@code{widen})。
@item C-x n p
現在のページにナローイングします(@code{narrow-to-page})。
@item C-x n d
現在のdefunにナローイングします(@code{narrow-to-defun})。
@end table

  バッファーをナローイングしているときは、表示されている範囲がすべてです。残りの部分を見ることはできず、移動もできず(移動コマンドによりアクセス可能範囲の外に移動することはできません)、変更もできません。しかし残りの部分がなくなったわけではないので、ファイルを保存するとアクセス不能範囲のテキストもすべて保存されます。ナローイングが有効なときは、モードラインに@samp{Narrow}という単語が表示されます。

@kindex C-x n n
@findex narrow-to-region
  主要なナローイングコマンドは、@kbd{C-x n n}
(@code{narrow-to-region})です。これは現在のバッファーを制限するので、現在のリージョンだけがアクセス可能になり、リージョンの前後のすべてのテキストはアクセス不能になります。ポイントとマークは変化しません。

@kindex C-x n p
@findex narrow-to-page
@kindex C-x n d
@findex narrow-to-defun
  かわりに@kbd{C-x n p}
(@code{narrow-to-page})を使うと、現在のページにナローイングされます。ページの定義については、@ref{Pages}を参照してください。@kbd{C-x
n d}
(@code{narrow-to-defun})は、ポイントを含むdefunにナローイングします(@ref{Defuns}を参照してください)。

@kindex C-x n w
@findex widen
  ナローイングを取り消す方法は、@kbd{C-x n w}
(@code{widen})です。これにより再びバッファーのテキストすべてにアクセス可能になります。

  バッファーのどの範囲にナローイングされているかは、@kbd{C-x =}コマンドを使って情報を得ることができます。@ref{Position
Info}を参照してください。

  ナローイングは、それを理解していないユーザーを容易に混乱させるので、通常@code{narrow-to-region}コマンドは無効になっています。このコマンドを使おうとすると、Emacsは確認を求め、有効にするオプションを提供します。このコマンドを有効にすると、それ以降は確認を求められなくなります。@ref{Disabling}を参照してください。

@node View Mode
@section Viewモード
@cindex View mode
@cindex mode, View

@kindex s @r{(View mode)}
@kindex SPC @r{(View mode)}
@kindex DEL @r{(View mode)}
  Viewモードは、バッファーをスクリーン上でスキャンするためのマイナーモードです。このモードは、バッファーを変更せずにスクロールする、便利なコマンドを提供します。Emacsのカーソル移動コマンドとは別に、@key{SPC}で前方にスクロール、@kbd{S-@key{SPC}}または@key{DEL}で後方にスクロール、@kbd{s}でインクリメンタルサーチができます。

@kindex q @r{(View mode)}
@kindex e @r{(View mode)}
@findex View-quit
@findex View-exit
  @kbd{q}
(@code{View-quit})とタイプするとViewモードが無効になり、Viewモードが有効になる前のパッファーの位置に戻ります。@kbd{e}
(@code{View-exit})とタイプするとViewモードが無効になり、現在のバッファーと位置は維持されます。

@findex view-buffer
@findex view-file
  @kbd{M-x
view-buffer}は、既存のEmacsバッファー名を入力として求め、そのバッファーに切り替えてViewモードを有効にします。@kbd{M-x
view-file}はファイル名を入力として求め、そのファイルをvisitしてViewモードを有効にします。

@node Follow Mode
@section Followモード
@cindex Follow mode
@cindex mode, Follow
@findex follow-mode
@cindex windows, synchronizing
@cindex synchronizing windows

  @dfn{Followモード}は、同じバッファーを表示する2つのウィンドウを、1つの``仮想ウィンドウ''としてスクロールするマイナーモードです。Followモードを使うには、ウィンドウが1つだけのフレームを選択して、それを@kbd{C-x
3}を使って縦に並べて2分割してから、@kbd{M-x
follow-mode}とタイプします。それ以降はバッファーをどちらのウィンドウでも編集でき、どちらかのウィンドウをスクロールすると、他方のウィンドウも追従してスクロールします。

  Followモードでは、一方のウィンドウで表示されている部分の外にポイントを移動して、もう一方のウィンドウで表示されている部分にポイントを移動させると、そのウィンドウが選択されます。つまり2つのウィンドウを1つの大きなウィンドウとして扱えるのです。

  Followモードをオフにするには、もう一度@kbd{M-x follow-mode}とタイプしてください。

@node Faces
@section テキストのフェイス
@cindex faces

  Emacsは@dfn{フェイス(faces)}と呼ばれる仕組みを通じて、テキストをいくつかの異なるスタイルで表示できます。フェイスにはfont(フォント)、height(高さ)、weight(太さ)、slant(傾き)、foreground(前景)およびbackground(背景)、underline(アンダーライン)、overline(オーバーライン)などの様々な@dfn{フェイス属性(face
attributes)}を指定できます。ほとんどのメジャーモードはFont
Lockモードを通じて、テキストに自動的にフェイスを割り当てます。これらのフェイスを割り当てる方法については、@ref{Font
Lock}を参照してください。

@findex list-faces-display
  現在定義されているフェイスと、それがどのような外観なのかを見るには、@kbd{M-x
list-faces-display}とタイプします。プレフィクス引数を指定すると、このコマンドは正規表現の入力を求め、その正規表現にマッチするフェイスだけを表示します(@ref{Regexps}を参照してください)。

@vindex frame-background-mode
  あるフェイスが、フレームが異なると違って見えるのことがあり得ます。たとえばいくつかのテキスト端末ではすべてのフェース属性、特に特にfont、height、widthはサポートされておらず、指定できるcolorも限られているものがあります。加えて、ほとんどのEmacsフェースは視認性をよくするために、フレームのバックグラウンドが明るい(light)か暗い(dark)かで属性が異なります。デフォルトでは、Emacsはフレームの現在のバックグラウンドカラーに基づいて、表示するフェイスの属性を自動的に選択します。しかし変数@code{frame-background-mode}に非@code{nil}値を与えると、これをオーバーライドできます。値@code{dark}ではすべてのフレームの背景色が暗い色であるかのように処理し、値@code{light}ではすべてのフレームの背景色が明るい色であるかのように処理させることができます。

@cindex background color
@cindex default face
  フェイスの属性を変えてフェイスをカスタマイズして、将来のEmacsセッション用にカスタマイズ結果を保存することができます。詳細については、@ref{Face
Customization}を参照してください。

  @code{default}フェイスはテキストを表示するデフォルトのフェイスで、そのすべての属性は指定されています。バックグラウンドカラーは、フレームのバックグラウンドカラーとしても使用されます。@ref{Colors}を参照してください。

@cindex cursor face
  他の特別なフェイスとしては、@code{cursor}フェイスがあります。グラフィカルなディスプレーでは、このフェイスのバックグラウンドカラーは、テキストカーソルを描画するのに使用されます。このフェイスで効果があるのはこの属性だけです。カーソルの下のテキストのフォアグラウンドカラーには、そのテキストのバックグラウンドカラーが使われます。テキスト端末でのテキストカーソルの外観は、@code{cursor}フェイスではなく端末により決定されます。

  特定のフェイスの属性を指定するのにXのリソースを使うこともできます。@ref{Resources}を参照してください。

  Emacsは可変幅フォント(variable-width
fonts)を表示できますが、いくつかのコマンド、特にインデントを行うコマンドは、可変幅の文字幅の表示をうまく処理できません。そのため、ほとんどのフェイスにたいして可変幅フォントを使わないこと、特にそれがFont
Lockモードに割り当てられている場合は、使わないことを推奨します。

@node Colors
@section フェイスのカラー
@cindex color name
@cindex RGB triplet

  フェイスには、さまざまなフォアグラウンドカラーとバックグラウンドカラーをもたせることができます。フェイスにカラーを指定するとき、たとえばフェイスをカスタマイズ(@ref{Face
Customization}を参照してください)するときは、@dfn{カラーネーム(color name)}か、@dfn{RGBトリプレット(RGB
triplet)}で指定することができます。

@findex list-colors-display
@vindex list-colors-sort
  カラーネームとは、@samp{dark orange}や@samp{medium sea
green}のような、事前に定義された名前です。カラーネームの一覧を見るには、@kbd{M-x
list-colors-display}とタイプします。表示されるカラーの順番を制御するには、@code{list-colors-sort}をカスタマイズします。このコマンドをグラフィカルなディスプレーで実行すると、Emacsで既知のカラーネームのすべてが表示されます(これらは標準のX11のカラーネームで、Xの@file{rgb.txt}で定義されています)。コマンドをテキスト端末で実行すると、端末で安全に表示することができる一部のカラーだけが表示されます。フェイスには、さまざまなフォアグラウンドカラーとバックグラウンドカラーを持たせることができます。しかしEmacsは、テキスト端末でもX11のカラーネームを理解できます。もしフェイスにX11のカラーネームが指定されている場合、最も近い端末の色で表示されます。

  RGBトリプレットは、@samp{#RRGGBB}という形式の文字列で指定します。R、G、Bの各コンポーネントは、そのそのコンポーネントに関連する色の強度を、1桁から4桁(通常は2桁)の16進数で指定します。各コンポーネントは同じ桁数でなければなりません。16進数のAからFは、大文字小文字を区別しません。

  @kbd{M-x
list-colors-display}は、カラーネームと、それに相当するRGBトリプレットを表示します。たとえば@samp{medium sea
green}は@samp{#3CB371}と同じです。

@cindex face colors, setting
@findex set-face-foreground
@findex set-face-background
  @kbd{M-x set-face-foreground}と@kbd{M-x
set-face-background}で、フェイスのフォアグラウンドとバックグラウンドのカラーを変更できます。これらのコマンドは、ミニバッファーでフェイス名とカラーの入力を求め(補完機能あり)、指定したカラーをフェイスにセットします。フェイスのカラーは全フレームに影響しますが、カスタマイズバッファーやXリソースを使うのとは異なり、将来のEmacsセッションには引き継がれません。フレームパラメーターを使って、特定のフレームのフォアグラウンドとバックグラウンドのカラーをセットすることもできます。@ref{Frame
Parameters}を参照してください。

@node Standard Faces
@section 標準フェイス
@cindex standard faces

  以下はテキストの外見を指定する標準フェイスです。これらのフェイスの効果が欲しい場合は、特定のテキストに適用することができます。

@table @code
@item default
このフェイスは特定のフェイスをもたない普通のテキストに使われます。フェイスのバックグラウンドカラーは、フレームのバックグラウンドカラーとして使用されます。
@item bold
このフェイスは、デフォルトフォントのbold(太字)バージョンです。
@item italic
このフェイスはデフォルトフォントのitalic(斜体)バージョンです。
@item bold-italic
このフェイスはデフォルトフォントのbold italic(太字斜体)バージョンです。
@item underline
このフェイスはunderline(下線)のテキストです。
@item fixed-pitch
このフェイスはfixed-width
font(固定幅フォント)の使用を強制します。もし望むなら、このフェイスから他の固定幅フォントにカスタマイズするのは妥当ですが、可変幅フォントにするべきではありません。
@cindex variable-pitch face
@item variable-pitch
このフェイスはvariable-width font(可変幅フォント)の使用を強制します。
@cindex shadow face
@item shadow
このフェースはまわりのテキストに比べて、そのテキストを目立たなくします。通常これはデフォルトの黒または白のフォアグラウンドカラーではなく、グレーが使われます。
@end table

  以下は特別な目的のために、一時的にテキストの一部をハイライトするのに使われるフェイスの、不完全なリストです(他にも多くのモードが、そのモードの目的のために、独自のフェイスを定義しています)。

@table @code
@item highlight
このフェイスはさまざまなコンテキスト、たとえばハイパーリンク上をマウスカーソルが通過したときなどに、テキストをハイライトするのに使われます。
@item isearch
このフェイスは、現在のIsearch(インクリメンタル検索)のマッチをハイライトするのに使われます(@ref{Incremental
Search}を参照してください)。
@item query-replace
このフェイスは、現在の問い合わせ置換(Query
Replace)のマッチをハイライトするのに使われます(@ref{Replace}を参照してください)。
@item lazy-highlight
このフェイスは、Isearchおよび問い合わせ置換で、``カレントのマッチ(現在カーソルがあるマッチ)以外のマッチ(lazy
matches)''をハイライトするのに使われます。
@item region
このフェイスは、アクティブなリージョンを表示するのに使われます(@ref{Mark}を参照してください)。EmacsをGTKサポートつきでビルドした場合、カラーは現在のGTKのテーマから提供されます。
@item secondary-selection
このフェイスは、Xのセカンダリー選択(secondary X selection)を表示するのに使われます(@ref{Secondary
Selection}を参照してください)。
@item trailing-whitespace
このフェイスは、@code{show-trailing-whitespace}は非@code{nil}のとき、行末の余分なスペースやタブをハイライトするためのものです(@ref{Useless
Whitespace}を参照してください)。
@item escape-glyph
このフェイスは、制御文字やエスケープシーケンスを表示するためのものです(@ref{Text Display}を参照してください)。
@item nobreak-space
このフェイスは、``no-break''スペース文字を表示するためのものです(@ref{Text Display}を参照してください)。
@end table

  以下のフェイスは、Emacsフレームの一部の外見を制御します:

@table @code
@item mode-line
@cindex mode-line face
@cindex faces for mode lines
このフェイスは、現在選択されているウィンドウのモードラインと、ツールキットメニューが使われていないときのメニューバーに使われます。デフォルトでは、グラフィカルなウィンドウでは``raised''効果をだすため影つきで描画され、非ウィンドウの端末ではデフォルトのフェイスを反転して描画されます。
@item mode-line-inactive
@cindex mode-line-inactive face
@code{mode-line}と似ていますが、選択されていないウィンドウのモードラインに使われます(@code{mode-line-in-non-selected-windows}が非@code{nil}のとき)。このフェイスは@code{mode-line}を継承するので、フェイスを変更するとすべてのウィンドウのモードラインが影響を受けます。
@item mode-line-highlight
@cindex mode-line-highlight face
@code{highlight}と似ていますが、モードライン上でマウスセンシティブ(マウスに感応する)なテキスト範囲に使われます。通常このようなテキスト範囲は上にマウスポインターがくると、ツールチップ(@ref{Tooltips}を参照してください)をポップアップします。
@item mode-line-buffer-id
@cindex mode-line-buffer-id face
このフェイスは、モードライン上でバッファーを識別する部分に使われます。
@item header-line
@cindex header-line face
@code{mode-line}と似ていますが、ウィンドウのヘッダーラインのためのものです。モードラインがウィンドウの一番下に表示されるように、ヘッダーラインはウィンドウの一番上に表示されます。ほとんどのウィンドウはヘッダーラインを持ちません。Infoモードのような特別なモードだけがヘッダーラインを持ちます。
@item vertical-border
@cindex vertical-border face
このフェイスは、テキスト端末上でウィンドウを縦に分割するとき使われます。
@item minibuffer-prompt
@cindex @code{minibuffer-prompt} face
@vindex minibuffer-prompt-properties
このフェイスは、ミニバッファーで入力を求めるプロンプトのテキストに使われます。デフォルトでは、Emacsは自動的にプロンプトのテキストの、テキストプロパティのリスト@code{minibuffer-prompt-properties}に、このフェイスを追加します(この変数はミニバッファーに入ったときに効果をあらわします)。
@item fringe
@cindex @code{fringe} face
グラフィカルなウィンドウでの、左右のフリンジのためのフェイスです(フリンジはEmacsフレームで、テキストエリアとウィンドウの左右の境界線の間にある、狭い領域です)。@ref{Fringes}を参照してください。
@item cursor
このフェイスの@code{:background}属性は、テキストカーソルのカラーを指定します。@ref{Cursor
Display}を参照してください。
@item tooltip
このフェイスは、ツールチップのテキストに使われます。デフォルトでは、EmacsがGTKサポートつきでビルドされた場合、ツールチップはGTKを通じて描画されるので、このフェイスは効果がありません。@ref{Tooltips}を参照してください。
@item mouse
このファイスは、マウスポインターのカラーを決定します。
@end table

  以下のフェイスは、Emacsフレームの一部の外見を制御するときと同様ですが、テキスト端末またはEmacsをXサポートつき(ただしツールキットサポートなし)でビルドしたときだけ使われます(それ以外の場合、フレームの対応する各要素は広義なシステム設定により決定されます)。

@table @code
@item scroll-bar
このフェイスは、スクロールバーの外見を決定します。@ref{Scroll Bars}を参照してください。
@item tool-bar
このフェイスは、ツールバーのアイコンのカラーを決定します。@ref{Tool Bars}を参照してください。
@item menu
@cindex menu bar appearance
@cindex @code{menu} face, no effect if customized
@cindex customization of @code{menu} face
このフェイスはEmacsメニューのカラーとフォントを決定します。@ref{Menu Bars}を参照してください。
@item tty-menu-enabled-face
@cindex faces for text-mode menus
@cindex TTY menu faces
このフェイスは、テキスト端末で利用可能なメニューアイテムを表示するのに使われます。
@item tty-menu-disabled-face
このフェイスは、テキスト端末で利用不可なメニューアイテムを表示するのに使われます。
@item tty-menu-selected-face
このフェイスは、テキスト端末でマウスをクリックするか、@key{RET}を押せば選択できるメニューアイテムを表示するのに使われます。
@end table

@node Text Scale
@section テキストのスケール

@cindex adjust buffer face height
@findex text-scale-adjust
@kindex C-x C-+
@kindex C-x C--
@kindex C-x C-=
@kindex C-x C-0
  現在のバッファーのデフォルトフェイスを大きくするには、@kbd{C-x C-+}または@kbd{C-x
C-=}をタイプします。小さくするには、@kbd{C-x
C--}をタイプします。デフォルトのフェースの大きさ(グローバル)に復元するには、@kbd{C-x
C-0}とタイプします。これらのキーは、すべて同じコマンド@code{text-scale-adjust}にバインドされており、このコマンドは最後のキーを判断して動作を決定します。

  これらのコマンドの最後のキーは、@kbd{C-x}を前置せずに繰り返すことができます。たとえば@kbd{C-x C-= C-=
C-=}は、フェイスの大きさを3段階に大きくします。各ステップで大きくなる倍率は1.2です。この倍率を変更するには、変数@code{text-scale-mode-step}をカスタマイズします。@code{text-scale-adjust}コマンドに数引数0を指定すると、@kbd{C-x
C-0}とタイプしたのと同様に、デフォルトの大きさに復元します。

@cindex increase buffer face height
@findex text-scale-increase
@cindex decrease buffer face height
@findex text-scale-decrease
  コマンド@code{text-scale-increase}および@code{text-scale-decrease}は、@kbd{C-x
C-+}および@kbd{C-x
C--}と同様、デフォルトフェイスを大きくまたは小さくします。キーをバインドする場合、これらのコマンドは、@code{text-scale-adjust}より便利でしょう。

@cindex set buffer face height
@findex text-scale-set
  コマンド@code{text-scale-set}は、数引数で現在のバッファーのデフォルトフェイスの大きさを、絶対倍率で指定します。

@findex text-scale-mode
  上記のコマンドは、現在のフォント倍率が1以外のときは、自動的にマイナーモード@code{text-scale-mode}を有効にし、そうでない場合は無効にします。

@node Font Lock
@section Font Lockモード
@cindex Font Lock mode
@cindex mode, Font Lock
@cindex syntax highlighting and coloring

  Font
Lockモードはマイナーモードで、常に特定のバッファーにローカルで、バッファーのテキストにフェイスを割り当てます(または@dfn{フォント表示化(fontifies)します})。各バッファーのメジャーモードは、Font
Lockモードにどのテキストをフォント表示可するか指示します。たとえばプログラム言語のモードは、コメントや文字列、関数名のような、構文に関連する構成をフォント表示化します。

@findex font-lock-mode
  Font Lockモードはデフォルトで有効です。現在のバッファーでこれを切り替えるには、@kbd{M-x
font-lock-mode}とタイプします。正の数引数は無条件にFont Lockモードを有効にし、負または0の数引数を指定すると無効になります。

@findex global-font-lock-mode
@vindex global-font-lock-mode
  @kbd{M-x global-font-lock-mode}とタイプすると、すべてのバッファーでFont
Lockモードを切り替えます。このセッティングを将来のEmacsセッションに引き継ぐには、変数@code{global-font-lock-mode}をカスタマイズ(@ref{Easy
Customization}を参照してください)するか、以下の行をinitファイルに追加します。

@example
(global-font-lock-mode 0)
@end example

@noindent
Global Font Lockモードを無効にしていたとしても、モードフック(mode
hooks)に関数を追加することにより、特定のメジャーモードでFont Lockモードを有効にできます。たとえばCファイルの編集でFont
Lockモードを有効にするには、以下のように記述します:

@example
(add-hook 'c-mode-hook 'font-lock-mode)
@end example

  Font
Lockモードは、@code{font-lock-string-face}、@code{font-lock-comment-face}のような、いくつかの特別な名前のフェイスを使って処理を行います。これらすべてを簡単に探す方法には、@kbd{M-x
customize-group @key{RET} font-lock-faces
@key{RET}}を使います。それからカスタマイズバッファーでそれらのフェイスの外見をカスタマイズできます。@ref{Face
Customization}を参照してください。

@vindex font-lock-maximum-decoration
  変数@code{font-lock-maximum-decoration}をカスタマイズして、Font
Lockモードで適用されるフォント表示化のレベルを変更できます。値には数字を指定します(1は最小限のフォント表示化で、3という高いレベルのモードもあります)。@code{t}は``可能な限り高く''という意味です(デフォルト)。特定のモードに異なる数字を指定することもできます。たとえばC/C++モードにはレベル1を指定して、他のモードにはデフォルトのレベルを適用するには、以下の値を使います:

@example
'((c-mode . 1) (c++-mode . 1)))
@end example

@vindex font-lock-beginning-of-syntax-function
@cindex incorrect fontification
@cindex parenthesis in column zero and fontification
@cindex brace in column zero and fontification
  コメントと文字列のフォント表示化(または``構文的''なフォント表示化)は、バッファーのテキストの構文構造の解析に依存します。速度向上のため、Lispモードを含めたいくつかのモードでは、特別な慣習に依存しています。たとえば一番左の列の開きカッコ(open-parenthesis)または開き大カッコ(open-brace)は常にdefunの開始であり、すなわち常に文字列またはコメントの外部にあるとみなす、というように解析します。したがって文字列やコメントの中で、一番左の列に開きカッコや開き大カッコを記述するのは避けるべきです。詳細については、@ref{Left
Margin Paren}を参照してください。

@cindex slow display during scrolling
  常にバッファーローカルな変数@code{font-lock-beginning-of-syntax-function}は、Font
Lockモードがコメント、もしくは文字列の外であることが保証される位置を探す方法を指定します。それが最左列がカッコであるという慣習をもつモードでは、変数のデフォルト値は@code{beginning-of-defun}で、Font
Lockモードがその慣習にしたがうよう指定します。この変数に@code{nil}をセットすると、Font
Lockモードはもはや慣習には依存しなくなります。これでまちがった結果を避けられますが、その代償はとして、変更したテキストをフォント表示化するに、バッファのテキストをバッファの先頭から再走査しなければならない場合もあります。これはスクロールに相当な速度低下を招きかねず、大きなバッファーの最後に近い位置では、それが特に顕著になります。

@findex font-lock-add-keywords
  Font
Lockは、ほとんどのモードで既存のパターンをハイライトしますが、追加のパターンをフォント表示化したいときもあるでしょう。特定のモードでハイライトするパターンを追加するには、関数@code{font-lock-add-keywords}を使うことができます。たとえばCコメント中の@samp{FIXME:}という単語をハイライトするには、以下を使います:

@example
(add-hook 'c-mode-hook
          (lambda ()
           (font-lock-add-keywords nil
            '(("\\<\\(FIXME\\):" 1
               font-lock-warning-face t)))))
@end example

@findex font-lock-remove-keywords
@noindent
font-lockのハイライトパターンからキーワードを削除するには、関数@code{font-lock-remove-keywords}を使います。@ref{Search-based
Fontification,,, elisp, The Emacs Lisp Reference Manual}を参照してください。

@cindex just-in-time (JIT) font-lock
@cindex background syntax highlighting
  大きなバッファーのフォント表示化には、長い時間を要することもあります。ファイルをvisitしたとき大きな遅延を避けるには、Emacsが最初はバッファーの表示された部分だけをフォント表示化するようにします。バッファーをスクロールすると、新たに表示される部分がフォント表示化されます。このタイプのFont
Lockは、@dfn{Just-In-Time}(または@dfn{JIT})
Lockと呼ばれます。カスタマイズグループ@samp{jit-lock}の値をカスタマイズすることにより、アイドル状態のときにフォント表示可を行うことも含めて、JIT
Lockがどのように振る舞うか制御できます。@ref{Specific Customization}を参照してください。

@node Highlight Interactively
@section インタラクティブなハイライト
@cindex highlighting by matching
@cindex interactive highlighting
@cindex Highlight Changes mode

@findex highlight-changes-mode
Highlight
Changesモードは、最近変更されたバッファー部分のテキストに、異なるフェイスを与えることにより@dfn{ハイライト}するマイナーモードです。Highlight
Changesモードを有効または無効にするには、@kbd{M-x highlight-changes-mode}を使います。

@cindex Hi Lock mode
@findex hi-lock-mode
  Hi
Lockモードは、指定した正規表現にマッチするテキストをハイライトする、マイナーモードです。たとえば、プログラムのソースファイルで、特定の変数へのすべての参照をハイライトしたり、何らかのプログラムの大量の出力の一部をハイライトしたり、記事中の特定の名前をハイライトするために使用できます。Hi
Lockモードを有効または無効にするには、コマンド@kbd{M-x hi-lock-mode}を使います。すべてのバッファーでHi
Lockモードを有効にするには、@kbd{M-x
global-hi-lock-mode}を使うか、@file{.emacs}ファイルに@code{(global-hi-lock-mode
1)}と記述してください。

  Hi LockモードはFont Lockモード(@ref{Font
Lock}を参照してください)と同じように動作しますが、ハイライトするパターンを明示的に正規表現で指定します。これらは以下のコマンドで制御できます:

@table @kbd
@item M-s h r @var{regexp} @key{RET} @var{face} @key{RET}
@itemx C-x w h @var{regexp} @key{RET} @var{face} @key{RET}
@kindex M-s h r
@kindex C-x w h
@findex highlight-regexp
@var{regexp}にマッチするテキストを、フェイス@var{face}を使ってハイライトします(@code{highlight-regexp})。ハイライトはバッファーがロードされている限り残ります。たとえば単語``whim''をデフォルトのフェイス(黄色いバックグラウンドカラー)でハイライトするには、@kbd{M-s
h r whim @key{RET} @key{RET}}とタイプします。ハイライトには任意のフェイスを使うことができますが、Hi
Lockモードはモード自身でいくつかのフェイスを提供しており、それらはデフォルト値のリストに事前ロードされています。フェイスの入力プロンプトで@kbd{M-n}と@kbd{M-p}を使うことにより、それらを巡回することができます。

@vindex hi-lock-auto-select-face
オプション@code{hi-lock-auto-select-face}に非@code{nil}値をセットすることにより、このコマンド(およびその他のフェイスを読みとるHi
Lockコマンド)は、入力を求めることなく、デフォルト値のリストから次のフェイスを自動的に選択します。

このコマンドを複数回使用して、さまざまな正規表現を指定し、それぞれを異なる方法でハイライトできます。

@item M-s h u @var{regexp} @key{RET}
@itemx C-x w r @var{regexp} @key{RET}
@kindex M-s h u
@kindex C-x w r
@findex unhighlight-regexp
@var{regexp}のハイライトを解除します(@code{unhighlight-regexp})。

メニューから呼び出した場合、ハイライト解除する正規表現をリストから選択します。キーボードから呼び出した場合は、ミニバッファーを使います。一番最近追加された正規表現を表示し、@kbd{M-n}を使って次に古い正規表現、@kbd{M-p}で次に新しい正規表現を表示できます(手入力もでき、その場合は補完機能つきです)。ハイライト解除したい正規表現がミニバッファーに表示されたら、@kbd{@key{RET}}を押してミニバッファーを抜けだし、ハイライトを解除できます。

@item M-s h l @var{regexp} @key{RET} @var{face} @key{RET}
@itemx C-x w l @var{regexp} @key{RET} @var{face} @key{RET}
@kindex M-s h l
@kindex C-x w l
@findex highlight-lines-matching-regexp
@cindex lines, highlighting
@cindex highlighting lines of text
@var{regexp}とのマッチを含む行全体を、フェイス@var{face}を使ってハイライトします(@code{highlight-lines-matching-regexp})。

@item M-s h p @var{phrase} @key{RET} @var{face} @key{RET}
@itemx C-x w p @var{phrase} @key{RET} @var{face} @key{RET}
@kindex M-s h p
@kindex C-x w p
@findex highlight-phrase
@cindex phrase, highlighting
@cindex highlighting phrase
@var{phrase}にマッチするフレーズを、フェイス@var{face}でハイライトします(@code{highlight-phrase})。@var{phrase}には正規表現を指定できますが、スペースは空白文字にマッチする正規表現に置き換えられます。また、先頭に小文字を使用することにより、大文字小文字を区別しなくなります。

@item M-s h .
@itemx C-x w .
@kindex M-s h .
@kindex C-x w .
@findex highlight-symbol-at-point
@cindex symbol, highlighting
@cindex highlighting symbol at point
ポイントの近くで見つかったシンボルを、次に利用可能なフェイスでハイライトします(@code{highlight-symbol-at-point})。

@item M-s h w
@itemx C-x w b
@kindex M-s h w
@kindex C-x w b
@findex hi-lock-write-interactive-patterns
現在ハイライトを行っている正規表現/フェイスのペアを、バッファーのポイント位置に挿入します。挿入はプログラムを変更してしまわないように、コメント文字列でコメント化されます(このキーバインドは@code{hi-lock-write-interactive-patterns}コマンドを実行します)。

これらのパターンは、コメントからも逆抽出されます。それは、コメントに記述されたテキストが適正で、@kbd{M-x
hi-lock-find-patterns}を呼び出した、あるいはHi
Lockモードが有効なときファイルをvisit(これは@code{hi-lock-find-patterns}を実行します)したときです。

@item M-s h f
@itemx C-x w i
@kindex M-s h f
@kindex C-x w i
@findex hi-lock-find-patterns
正規表現/フェイスのペアを、現在のバッファーのコメントから抽出します(@code{hi-lock-find-patterns})。これらのコマンドを使えば、@code{highlight-regexp}でパターンを対話的に入力、@code{hi-lock-write-interactive-patterns}でそれをファイルに保存、それらを編集(あるマッチのフェイスを別のフェイスにしたり)、そして最後にこのコマンド(@code{hi-lock-find-patterns})で編集済みのパターンを、Hi
Lockのハイライトに適用することができます。

@vindex hi-lock-file-patterns-policy
変数@code{hi-lock-file-patterns-policy}はファイルをvisitしたとき、Hi
Lockモードがパターンを探して、それを自動的に抽出するべきかを制御します。値には@code{nil}(ハイライトしない)、@code{ask}(ユーザーに尋ねる)、または関数を指定します。関数の場合、@code{hi-lock-find-patterns}はパターンを引数としてその関数を呼び出します。関数が非@code{nil}を返した場合、パターンを使用します。デフォルトは@code{ask}です。直接@code{hi-lock-find-patterns}を呼び出した場合、この変数の値に関係なく、常にパターンはハイライトされることに注意してください。

@vindex hi-lock-exclude-modes
現在のメジャーモードのシンボルが、リスト@code{hi-lock-exclude-modes}のメンバーの場合、@code{hi-lock-find-patterns}は何もしません。
@end table

@node Fringes
@section ウィンドウのフリンジ
@cindex fringes

@findex set-fringe-style
@findex fringe-mode
@vindex fringe-mode @r{(variable)}
  グラフィカルなディスプレーでは、通常Emacsの各ウィンドウの左右の端に、狭い@dfn{フリンジ(fringes:
縁、へり)}があります。フリンジは、ウィンドウのテキストに関する情報を提供するシンボルの表示に使用されます。@kbd{M-x
fringe-mode}とタイプしてフリンジを無効にしたり、幅を変更できます。このコマンドは全フレームのフリンジに影響します。選択されたフレームのフリンジだけを変更するには、@kbd{M-x
set-fringe-style}を使います。変数@code{fringe-mode}をカスタマイズして、フリンジへの変更を永続化できます。

  フリンジのもっとも一般的な使われかたは、継続行の表示です(@ref{Continuation
Lines}を参照してください)。テキストの1行が複数のスクリーン行に分割されるとき、最初の行を除いた各行の左フリンジには曲矢印が表示され、その行の先頭が``実際の行頭ではない''ことを示します。そして、最後の行を除いた各行の右フリンジにも曲矢印が表示され、その行の最後が``実際の行末ではない''ことを示します。行の方向が右から左(@ref{Bidirectional
Editing}を参照してください)の場合、フリンジの曲矢印の意味は逆になります。

  行が切り詰められているときは水平方向の直矢印を表示して、``この行には水平スクロールしなければ見ることのできないテキストがある''ことを示します。矢印の上でマウスをクリックすれば、矢印の指す方向に水平スクロールします。

  フリンジはバッファーの境界(@ref{Displaying
Boundaries}を参照してください)や、デバッグ(@ref{Debuggers}を参照してください)しているプログラムが実行中であることを示すためにも使われます。

@vindex overflow-newline-into-fringe
  現在の行がウィンドウの幅と正確に一致して、ポイントがその行の行末にある場合、フリンジにはカーソルが描画されます。これを無効にするには、変数@code{overflow-newline-into-fringe}を@code{nil}に変更します。これによりEmacsはウィンドウ幅と同じ長さの行にたいしても、継続または切り詰めを行います。

@node Displaying Boundaries
@section バウンダリーの表示

@vindex indicate-buffer-boundaries
  グラフィカルなディスプレーでは、Emacsはバッファーのバウンダリー(boundary:
境界)を、フリンジに表示することもできます。この機能を有効にすると、最初の行と最後の行ではフリンジに、かぎカッコが表示されます。上矢印または下矢印の場合、それはウィンドウをその方向に、もっとスクロールできることを示します。

  バッファーローカルな変数@code{indicate-buffer-boundaries}は、バッファーのバウンダリーととウィンドウのスクロールが、フリンジでどのように表示されるかを制御します。値が@code{left}(または@code{right})の場合、かぎカッコと矢印のビットマップは、左フリンジ(または右フリンジ)に表示されます。

  値がalist(association list: 連想リスト)の場合、各要素の@code{(@var{indicator} .
@var{position})}で、標識(indicator)の位置(position)を指定します。@var{indicator}には@code{top}、@code{bottom}、@code{up}、@code{down}、または@code{t}(指定されていない標識のデフォルト位置)を指定します。@var{position}には@code{left}、@code{right}、または@code{nil}(標識を表示しない)を指定します。

  たとえば@code{((top . left) (t
.
right))}は、最上行の左フリンジにかぎカッコを表示し、右フリンジには最下行のかぎカッコとスクロール矢印を表示します。左フリンジにかぎカッコだけを表示させる場合は、@code{((top
.  left)  (bottom . left))}を使います。

@node Useless Whitespace
@section 不要なスペース

@cindex trailing whitespace
@cindex whitespace, trailing
@vindex show-trailing-whitespace
  意識せずに不必要なスペースを行末に残してしまったり、バッファーの最後に空行を残してしまうことはよくあります。ほとんどの場合、そのような@dfn{行末の空白文字(trailing
whitespace)}は何の影響も及ぼしませんが、厄介物になる場合もあります。

@cindex trailing-whitespace face
  バッファーローカルな変数@code{show-trailing-whitespace}を@code{t}にセットすることにより、行末の空白文字を可視化できます。これによりEmacsはフェイス@code{trailing-whitespace}で、行末の空白文字を表示します。

  この機能は行末に空白文字を含む行の、行末にポイントがあるときは適用されません。厳密にいえば、これも``行末の空白文字''なのですが、それを特別に表示してしまうと、新しいテキストをタイプするとき面倒です。このような特別なケースでは、ポイントの位置に表示されるカーソルより、空白文字があることが自明だからです。

@findex delete-trailing-whitespace
@vindex delete-trailing-lines
  @kbd{M-x
delete-trailing-whitespace}とタイプすると、すべての行末の空白文字を削除します。このコマンドは、バッファー内の各行の行末にあるすべての余分なスペースと、バッファーの最後にある空行を削除します。バッファー内の空行を削除しない場合は、変数@code{delete-trailing-lines}を@code{nil}に変更してください。リージョンがアクティブのときは、リージョン内の各行の行末の余分なスペースを削除します。

@vindex indicate-empty-lines
@cindex unused lines
@cindex fringes, and unused line indication
  グラフィカルなディスプレーでは、Emacsはウィンドウの最後の使われていない行の左フリンジに小さなイメージを表示して、それを示すことができます。このイメージはバッファーのテキストが何も含まれていないスクリーン行に表示されるので、バッファーの最後にある空行は、このイメージが表示されないことで見分けることができます。この機能を有効にするにはバッファーローカルな変数@code{indicate-empty-lines}に非@code{nil}値をセットします。すべての新しいバッファーでこの機能を有効または無効にするには、この変数のデフォルト値をセットします(例
@code{(setq-default indicate-empty-lines t)})

@cindex Whitespace mode
@cindex mode, Whitespace
@findex whitespace-mode
@vindex whitespace-style
  Whitespaceモードはバッファーローカルなマイナーモードで、バッファー内にある多くの種類の空白文字を``視覚化''します。これは空白文字を特別なフェイスで描画するか、特別なグリフで表示することにより行われます。このモードを切り替えるには、@kbd{M-x
whitespace-mode}とタイプします。視覚化される空白文字の種類は、リスト変数@code{whitespace-style}により決定されます。以下はリストに指定できる要素の一部です(完全なリストは変数のドキュメントを参照してください)。

@table @code
@item face
特別なフェイスを使った視覚化をすべて有効にします。この要素には特別な意味があります。もしこれがリストに含まれていない場合、@code{space-mark}、@code{tab-mark}、@code{newline-mark}を除く他の視覚化は効果がなくなります。

@item trailing
行末の空白文字をハイライトします。

@item tabs
タブ文字をハイライトします。

@item spaces
スペースおよびnon-breaking space文字をハイライトします。

@item lines
@vindex whitespace-line-column
80列以上の行をハイライトします。列の上限を変更するには、変数@code{whitespace-line-column}をカスタマイズします。

@item newline
改行をハイライトします。

@item empty
空行をハイライトします。

@item space-mark
スペースとnon-breaking文字を特別なグリフで描画します。

@item tab-mark
タブ文字を特別なグリフで描画します。

@item newline-mark
改行文字を特別なグリフで描画します。
@end table

@node Selective Display
@section 選択的な表示
@cindex selective display
@findex set-selective-display
@kindex C-x $

  Emacsには、与えられたレベルより多くインデントされた行を隠す機能があります。これをプログラムの概要を理解するのに使うことができます。

  現在のバッファーの行を隠すには、数引数@var{n}を指定して@kbd{C-x $}
(@code{set-selective-display})をタイプします。すると少なくとも@var{n}列のインデントをもつ行は、スクリーンに表示されなくなります。隠された行の存在を示すのは、表示されている行末に表示された3つのドット(@samp{@dots{}})だけで、これは1行以上の行が後に隠されていることを意味します。

  コマンド@kbd{C-n}および@kbd{C-p}は、隠された行が存在しないかのように、隠された行をスキップして移動します。

  隠された行は依然としてバッファーに存在し、ほとんどの編集コマンドはそれらを見ることができるので、隠されな行にポイントを移動することもありえます。これが起こるとカーソルは前の行の最後、つまり3つのドットの後ろに表示されます。ポイントが表示されている行の行末、つまり改行の前にある場合、カーソルは3つのドットの前に表示されます。

  隠された行のすべてを再び表示するには、引数を指定せずに@kbd{C-x $}とタイプしてください。

@vindex selective-display-ellipses
  変数@code{selective-display-ellipses}に@code{nil}をセットすると、隠された行があることを示す3つのドットは表示されなくなり、隠された行があることを示す視覚的な表示はなくなります。変数がセットされると、それは自動的にローカルになります。

  バッファーのテキストの一部を隠す他の方法については、@ref{Outline Mode}を参照してください。

@node Optional Mode Line
@section モードラインのオプション

@cindex buffer size display
@cindex display of buffer size
@findex size-indication-mode
  バッファーのパーセント表示@var{pos}は、ウィンドウの上端がバッファーのどの場所にあるかを100分率で示します。@kbd{M-x
size-indication-mode}とタイプしてSize
Indicationモードをオンにすることにより、バッファーのサイズを追加で表示できます。サイズは以下のようにパーセント表示のすぐ後に表示されます:

@example
@var{pos} of @var{size}
@end example

@noindent
@var{size}は、バッファーの文字数を人間が理解しやすい形式(@samp{k}は10^3、@samp{M}は10^6、@samp{G}は10^9などの短縮形が使用されます)で表示します。

@cindex line number display
@cindex display of line number
@findex line-number-mode
  Line Numberモードが有効なとき、ポイント位置の現在の行番号はモードラインに表示されます。@kbd{M-x
line-number-mode}コマンドを使って、Line
Numberモードのオンとオフを切り替えることができます(通常はオンです)。行番号はそれが何であるかを示す文字@samp{L}とともに、バッファーのパーセント表示@var{pos}の後ろに表示されます。

@cindex Column Number mode
@cindex mode, Column Number
@findex column-number-mode
  同様に、@kbd{M-x column-number-mode}でColumn
numberモードをオンにすることにより、現在の列番号を表示できます。列番号は文字@samp{C}で示されます。しかし両方のモードが有効になっているときは、行番号と列番号は@samp{L}や@samp{C}ではなく、@samp{(561,2)}のようにカッコつきで表示されます。マイナーモードとこれらのコマンドの使い方については、@ref{Minor
Modes}を参照してください。

@cindex narrowing, and line number display
  ナローイング(@ref{Narrowing}を参照してください)によりバッファーを制限している場合、アクセスできる部分にもとづいた行番号が表示されます。そのため、これは@code{goto-line}の引数として使用するには適しません(ファイル全体にたいする行番号を見るには、@code{what-line}コマンドを使います)。

@vindex line-number-display-limit
  バッファーが非常に大きい場合(@code{line-number-display-limit}の値より大)、速度が遅くなるのでEmacsは行番号を計算しません。そのためモードラインに行番号は表示されません。この制限を取り除くには、@code{line-number-display-limit}に@code{nil}をセットします。

@vindex line-number-display-limit-width
  バッファーの行が長いときも、行番号の計算が遅くなります。この理由により、Emacsはポイントの近くの行の幅の平均文字数が、@code{line-number-display-limit-width}より大きいときは、行番号を表示しません。デフォルト値は200文字です。

@findex display-time
@cindex time (on mode line)
  Emacsはオプションで、時刻とシステムロードを、すべてのモードラインで表示できます。この機能を有効にするには、@kbd{M-x
display-time}とタイプするか、オプション@code{display-time-mode}をカスタマイズします。モードラインに追加される情報は以下のような形式です:

@example
@var{hh}:@var{mm}pm @var{l.ll}
@end example

@noindent
@vindex display-time-24hr-format
ここで@var{hh}と@var{mm}は時間と分で、後ろに@samp{am}と@samp{pm}がつきます。@var{l.ll}は、過去数分間における、システム全体で実行中または実行準備ができている(例:
利用可能なプロセッサー待ち)プロセスの平均数です(オペレーティングシステムがサポートしないフィールドは表示されません)。時刻を24時間表示にしたいときは、変数@code{display-time-24hr-format}に@code{t}をセットしてください。

@cindex mail (on mode line)
@vindex display-time-use-mail-icon
@vindex display-time-mail-face
@vindex display-time-mail-file
@vindex display-time-mail-directory
  もし未読メールがある場合、ロードレベルの後ろに@samp{Mail}という単語が表示されます。グラフィカルなディスプレーでは、@code{display-time-use-mail-icon}をカスタマイズすることにより、@samp{Mail}のかわりにアイコンを使うことができます。これによりモードラインのスペースが多少節約できます。@code{display-time-mail-face}をカスタマイズして、メールの表示を目立たせることができます。@code{display-time-mail-file}を使ってチェックするメールファイルを指定したり、@code{display-time-mail-directory}で受信メールのディレクトリーを指定できます(ディレクトリー内の空でない普通のファイルは、``新しい受信メール''と判断されます)。

@cindex battery status (on mode line)
@findex display-battery-mode
@vindex display-battery-mode
@vindex battery-mode-line-format
  Emacsをラップトップコンピューターで実行している場合、コマンド@code{display-battery-mode}を使うか、変数@code{display-battery-mode}をカスタマイズすることにより、モードラインにバッテリー充電状況を表示できます。変数@code{battery-mode-line-format}は、バッテリーの充電状況の表示方法を決定します。モードラインに表示されるメッセージの正確さはオペレーティングシステムに依存しており、通常はバッテリーの充電トータルにたいする現在のバッテリー充電率が表示されます。

@cindex mode line, 3D appearance
@cindex attributes of mode line, changing
@cindex non-integral number of lines in a window
  グラフィカルなディスプレーでは、モードラインは立体的に描画されます。この効果が気に入らない場合は、@code{mode-line}フェイスをカスタマイズして、@code{box}属性に@code{nil}をセットすることにより無効にできます。@ref{Face
Customization}を参照してください。

@cindex non-selected windows, mode line appearance
  デフォルトでは、選択されていないウィンドウのモードラインは、@code{mode-line-inactive}と呼ばれる、別のフェイスで表示されます。選択されたウィンドウのモードラインだけが、@code{mode-line}フェイスで表示されます。これにより、どのウィンドウが選択されているかがわかりやすくなります。モードラインがないミニバッファーが選択されているときは、ミニバッファーをアクティブにしたウィンドウのモードラインが、@code{mode-line}で表示されます。結果として通常のミニバッファーの使用では、モードラインは変化しません。

@vindex mode-line-in-non-selected-windows
  変数@code{mode-line-in-non-selected-windows}を@code{nil}にセットすることにより、@code{mode-line-inactive}の使用を無効にできます。これによりすべてのモードラインが、@code{mode-line}フェイスで表示されます。

@vindex eol-mnemonic-unix
@vindex eol-mnemonic-dos
@vindex eol-mnemonic-mac
@vindex eol-mnemonic-undecided
  モードラインに表示される改行フォーマットは、変数@code{eol-mnemonic-unix}、@code{eol-mnemonic-dos}、@code{eol-mnemonic-mac}、および@code{eol-mnemonic-undecided}をセットすることにより、カスタマイズできます。

@node Text Display
@section テキストが表示される方法
@cindex characters (in text)
@cindex printing character

  ほとんどの文字は、@dfn{印字文字(printing
characters)}です。これらの文字がバッファーに存在すると、スクリーンにそのまま表示されます。印字文字には@acronym{ASCII}の数字、文字、区切り文字、同様に多くの非@acronym{ASCII}文字が含まれます。

@vindex tab-width
@cindex control characters on display
  @acronym{ASCII}文字セットには、印字されない@dfn{制御文字(control
characters)}が含まれます。その中でも特別に表示されるものが2つあります。1つ目は改行文字(Unicodeのコードポイント@code{U+000A})で、新しい行を開始するのに表示されます。2つ目はタブ文字(@code{U+0009})で、次のタブストップ(通常は8文字ごと)までをスペースで表示します。タブを何文字のスペースで表示するかは、バッファーローカルな変数@code{tab-width}で制御され、1から1000の整数で指定しなければなりません。バッファーのタブ文字がどのように表示されるかは、コマンドとしての@key{TAB}の定義には関係ないことに注意してください。

  他の@acronym{ASCII}制御文字としては、@code{U+0020}(8進の40、10進の32)より下のコードがあり、それらはカレット(@samp{^})と、その後ろに非制御文字バージョンの文字を続けて、@code{escape-glyph}フェイスで表示されます。たとえば文字@samp{control-A}(@code{U+0001})は、@samp{^A}と表示されます。

@cindex octal escapes
@vindex ctl-arrow
  コード@code{U+0080}(8進の200)から@code{U+009F}(8進の237)までのrawバイトは、@code{escape-glyph}フェイスにより、@dfn{8進エスケープシーケンス(octal
escape
sequences)}で表示されます。たとえば文字コード@code{U+0098}(8進の230)は、@samp{\230}と表示されます。バッファーローカルな変数@code{ctl-arrow}を@code{nil}に変更すると、@acronym{ASCII}制御文字も、カレットエスケープシーケンスではなく、8進エスケープシーケンスで表示されます。

@vindex nobreak-char-display
@cindex non-breaking space
@cindex non-breaking hyphen
@cindex soft hyphen
@cindex escape-glyph face
@cindex nobreak-space face
  非@acronym{ASCII}文字の中には、@acronym{ASCII}のスペースやハイフン(マイナス記号)と同じ外観を持つものがあります。そのような文字は、意識せずにバッファーに入力されたとき(たとえばyankなどで)、問題となることがあります。たとえばソースコードコンパイラーは通常、非@acronym{ASCII}のスペースを、空白文字として扱いません。この問題に対処するため、Emacsはそのような文字を特別な方法(@code{U+00A0}(no-break
space)は@code{nobreak-space}フェイス、@code{U+00AD}(soft
hyphen)、@code{U+2010}(hyphen)、@code{U+2011} (non-breaking
hyphen)は@code{escape-glyph}フェイス)で表示します。これを無効にするには、変数@code{nobreak-char-display}を@code{nil}に変更します。この変数に非@code{nil}かつ非@code{t}の値を与えると、Emacsはハイライトされたバックスラッシュの後に、スペースまたはハイフンを表示します。

  特定の文字コードの表示のカスタマイズは、ディスプレーテーブル(display table)によって行われます。@ref{Display Tables,,
Display Tables, elisp, The Emacs Lisp Reference Manual}を参照してください。

@cindex glyphless characters
@cindex characters with no font glyphs
  グラフィカルなディスプレーでは、Emacsが利用可能なフォントにグリフがない文字がいくつかあります。これらの@dfn{グリフがない文字(glyphless
characters)}は、通常16進文字を含むボックスで表示されます。テキスト端末では、端末エンコーディング(@ref{Terminal
Coding}を参照してください)で表示できない文字は、通常クエスチョン記号で表示されます。表示方法は、変数@code{glyphless-char-display-control}で制御できます。詳細は、@ref{Glyphless
Chars,, Glyphless Character Display, elisp, The Emacs Lisp Reference
Manual}を参照してください。

@node Cursor Display
@section カーソルの表示
@cindex text cursor

@vindex visible-cursor
  テキスト端末では、カーソルの外見は端末により制御され、大部分はEmacsの制御が及びません。いくつかの端末は、``普通の''固定的なカーソルと、``目立つ''点滅カーソルの2種類を提供します。デフォルトではEmacsは目立つカーソルを使い、Emacsを開始または再開したときは、そのカーソルに切り替えます。変数@code{visible-cursor}が@code{nil}の場合、Emacsを開始または再開したとき、普通のカーソルを使います。

@cindex cursor face
@vindex cursor-type
  グラフィカルなディスプレーでは、より多くのテキストカーソルのプロパティを変更できます。カラーを変えるには、フェイス@code{cursor}の、属性@code{:background}を変更します(このフェイスの他の属性には、何を指定しても効果はありません。カーソルの下にあるテキストはフレームのバックグラウンドカラーを使って描画されます)。外見を変更するには、バッファーローカルな変数@code{cursor-type}をカスタマイズします。有効な値は、@code{box}(デフォルト)、@code{hollow}(中抜きのボックス)、@code{bar}(垂直のバー)、@code{(bar
. @var{n})}(幅が@var{n}ピクセルの垂直バー), @code{hbar}(水平バー)、@code{(hbar
. @var{n})}(高さが@var{n}ピクセルの水平バー)、または@code{nil}(カーソルなし)です。

@findex blink-cursor-mode
@cindex cursor, blinking
@cindex blinking cursor
@vindex blink-cursor-mode
@vindex blink-cursor-blinks
@vindex blink-cursor-alist
  デフォルトでは、カーソルは10回点滅する間にEmacsに何も入力がないと、点滅をストップします。そして何らかの入力イベントがあると、また0からカウントを再開します。変数@code{blink-cursor-blinks}をカスタマイズして、これを制御できます。変数の値には、何の入力もないとき点滅をストップする点滅回数を指定します。変数に0または負の値をセットすると、カーソルはずっと点滅したままになります。カーソルの点滅を無効にするには、変数@code{blink-cursor-mode}を@code{nil}に変更するか(@ref{Easy
Customization}を参照してください)、initファイルに以下の行を追加します:

@lisp
  (blink-cursor-mode 0)
@end lisp

@noindent
リスト変数@code{blink-cursor-alist}をカスタマイズして、カーソルが"点滅をストップしたとき"、どのように見えるかを変更できます。リストの各要素は、@code{(@var{on-type}
.
@var{off-type})}という形式を指定します。@var{on-type}には、点滅しているときのカーソルを指定します(@var{on-type}には、上で説明したカーソルタイプを指定します)。そして@var{off-type}には、点滅していないときのカーソルを指定します。

@vindex x-stretch-cursor
@cindex wide block cursor
  タブ文字のように``特別に幅が広い''文字もあります。そのような文字上にカーソルがあるとき、通常はデフォルトの文字幅で描画されます。カーソルを文字幅に伸ばすには、変数@code{x-stretch-cursor}を非@code{nil}値に変更してください。

@cindex cursor in non-selected windows
@vindex cursor-in-non-selected-windows
  選択されていないウィンドウのカーソルは、通常点滅していない中抜きのボックスで表示されます(カーソルにバーを使っている場合、より細いバーで表示されます)。選択されていないウィンドウでカーソルを非表示にするには、変数@code{cursor-in-non-selected-windows}を@code{nil}に変更してください。

@findex hl-line-mode
@findex global-hl-line-mode
@cindex highlight current line
  カーソルをよりはっきりと表示させるために、HL
Lineモードを使用できます。このモードでは、ポイントを含む行がハイライトされます。現在のバッファーで有効または無効にするには、@kbd{M-x
hl-line-mode}を使います。このモードをグローバルに有効または無効にするには、@kbd{M-x
global-hl-line-mode}を使用してください。

@node Line Truncation
@section 行の切り詰め

@cindex truncation
@cindex line truncation, and fringes
  Emacsは行を継続(@ref{Continuation
Lines}を参照してください)するかわりに、長い行を@dfn{切り詰めて}表示できます。これは、スクリーンやウィンドウの幅より長い行は、全体が表示されないことを意味します。グラフィカルなディスプレーでは、行が切り詰められている場合、フリンジに小さな直矢印が表示されます。テキスト端末では、左端または右端の列に@samp{$}が表示されます。

@vindex truncate-lines
@findex toggle-truncate-lines
  水平スクロールは、自動的に行の切り詰めを引き起こします(@ref{Horizontal
Scrolling}を参照してください)。特定のバッファーにたいして行の切り詰めを明示的に有効にするには、コマンド@kbd{M-x
toggle-truncate-lines}を使います。これは変数@code{truncate-lines}をローカルに変更することで機能します。値が非@code{nil}のときは、長い行は切り詰められ、@code{nil}のときは複数のスクリーン行に分けられます。変数@code{truncate-lines}をセットすると、現在のバッファーにローカルに適用されます。値を変更するまでは、デフォルト値(@code{nil})が使われます。

@vindex truncate-partial-width-windows
  ウィンドウを分割して狭くなりすぎたとき、Emacsは自動的に行の切り詰めを有効にします。これを制御する変数@code{truncate-partial-width-windows}については、@ref{Split
Window}を参照してください。

@node Visual Line Mode
@section Visual Lineモード

@cindex word wrap
  このモードでは、通常の行継続の代わりに、@dfn{単語での折り返し}が使われます。通常の行継続のように、長い論理行は2行以上のスクリーン行に分割されます。しかしEmacsはウィンドウの右端の近くの、単語の境界で折り返すよう試みます。これは単語の途中で折り返さないことにより、可読性を高めるためです。

@cindex mode, Visual Line
@cindex Visual Line mode
@findex visual-line-mode
@findex global-visual-line-mode
  単語での折り返しは、オプションのマイナーモードである、Visual Lineモードで有効になります。現在のバッファーでVisual
Lineモードの有効と無効を切り替えるには、@kbd{M-x visual-line-mode}とタイプします。メニューバーからVisual
Lineモードを有効にすることもできます(Optionsメニューから、サブメニュー@samp{Line Wrapping in this
Buffer}の、メニューアイテム@samp{Word Wrap (Visual Line Mode)}を選択します)。Visual
Lineモードが有効なときは、モードラインのモード表示に@samp{wrap}という文字が表示されます。コマンド@kbd{M-x
global-visual-line-mode}は、全バッファーのVisual Lineモードを切り替えます。

@findex beginning-of-visual-line
@findex end-of-visual-line
@findex next-logical-line
@findex previous-logical-line
  Visual Lineモードでは、いくつかのコマンドは論理行ではなくスクリーン行に作用します。@kbd{C-a}
(@code{beginning-of-visual-line})はスクリーン行の先頭に移動し、@kbd{C-e}
(@code{end-of-visual-line})はスクリーン行の最後に移動、@kbd{C-k}
(@code{kill-visual-line})はテキストをスクリーン行の最後までkillします。

  論理行単位で移動するには、コマンド@kbd{M-x next-logical-line}または@kbd{M-x
previous-logical-line}を使います。これらのコマンドはVisual
Lineモードが有効であるかにかかわらず、次または前の論理行に移動します。これらのコマンドを頻繁に使う場合は、キーを割り当てると便利でしょう。@ref{Init
Rebinding}を参照してください。

  デフォルトでは、単語の折り返し表示はフリンジに表示されません。Visual
Lineモードは、長い論理行を含むファイルを編集するときに使われる場合があり、折り返し行すべてにフリンジの表示をすると見にくくなるためです。これを変更するには、変数@code{visual-line-fringe-indicators}をカスタマイズしてください。

@node Display Custom
@section ディスプレーのカスタマイズ

  このセクションでは、Emacsスクリーンの外観を制御するさまざまな変数を説明します。初心者はスキップして構いません。

@vindex visible-bell
  変数@code{visible-bell}が非@code{nil}の場合、Emacsは通常ベルサウンドを鳴らす場面で、スクリーン全体を点滅するよう試みます。端末がスクリーンを点滅させる方法を持たないとき、この変数は効果がありません。

@vindex echo-keystrokes
  変数@code{echo-keystrokes}は、複数文字キーのエコー表示を制御します。値にはエコーが開始されるまでの秒数を指定します。0の場合、エコーされません。何かエコーされるべきものがあるときは、この変数の値が効果をもちます。@ref{Echo
Area}を参照してください。

@cindex mouse pointer
@cindex hourglass pointer display
@vindex display-hourglass
@vindex hourglass-delay
  グラフィカルなディスプレーでは、Emacsはビジーのときにマウスポインターを砂時計で表示します。この機能を無効にするには、変数@code{display-hourglass}に@code{nil}をセットします。変数@code{hourglass-delay}は砂時計が表示されるまでの``busy
time''を、秒数で指定します。デフォルトは1です。

@vindex make-pointer-invisible
  マウスポインターがEmacsのフレーム内にある場合、文字をタイプしてテキストを挿入するまでの間、テキストを隠さないよう、Emacsはマウスポインターを非表示にします(正確に言うとマウスポインターの非表示は、``自己挿入的な(self-inserting)''文字をタイプしたときです。@ref{Inserting
Text}を参照してください)。マウスポインターを動かすと、再び表示されます。この機能を無効にするには、変数@code{make-pointer-invisible}に@code{nil}をセットしてください。

@vindex underline-minimum-offset
@vindex x-underline-at-descent-line
  グラフィカルなディスプレーでは、変数@code{underline-minimum-offset}は、アンダーラインされたテキストの、アンダーラインから文字の基底線までの最小距離を、ピクセルで決定します。デフォルトでは値は1です。この変数を増加させると、特定のフォントにおいて、アンダーラインされたテキストの可読性が向上します(しかしEmacsは、カレント行にはアンダーラインを描画しません)。変数@code{x-underline-at-descent-line}は、テキストにアンダーラインを引く方法を決定します。デフォルトは@code{nil}で、これはフォントの基底線と同じレベルに描画されることを意味します。非@code{nil}に変更すると、Emacsはフォントが同じ大きさになるよう、アンダーラインを少し下に描画します。

@vindex overline-margin
  変数@code{overline-margin}は、テキストの上のオーバーラインの垂直位置を、オーバーライン自身の高さも含めて、ピクセルで指定します。デフォルトは2です。

@findex tty-suppress-bold-inverse-default-colors
  テキスト端末には、bold(太字)かつ反転されたテキストが読みにくいものがあります。関数@code{tty-suppress-bold-inverse-default-colors}に、引数非@code{nil}を与えて呼び出すと、このような場合のbold-faceの効果を抑制します。
