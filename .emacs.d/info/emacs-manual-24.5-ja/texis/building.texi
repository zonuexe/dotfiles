@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c This is part of the Emacs manual.
@c Copyright (C) 1985-1987, 1993-1995, 1997, 2000-2015 Free Software
@c Foundation, Inc.
@c See file emacs.texi for copying conditions.
@node Building
@chapter プログラムのコンパイルとテスト
@cindex building programs
@cindex program building
@cindex running Lisp functions

  前のチャプターでは、プログラムを変更するのに便利なEmacsコマンドについて議論しました。このチャプターでは、プログラムのコンパイルとテストに役立つコマンドを扱います。

@menu
* Compilation::              Lisp以外の言語(C、Pascal、など)のプログラムのコンパイル。
* Compilation Mode::         コンパイラーのエラーをvisitするモード。
* Compilation Shell::        compilationバッファーで使えるように、シェルを適切にカスタマイズする。
* Grep Searching::           grepによる検索。
* Flymake::                  オンザフライでの構文エラーの検索。
* Debuggers::                非Lispプログラムのための、シンボルデバッガーの実行。
* Executing Lisp::           Lispプログラムを編集するためのさまざまなモードと、Lispプログラムを実行する異なる機能。
* Libraries: Lisp Libraries.  LispプログラムがEmacsにロードされる方法。
* Eval: Lisp Eval.           Emacsで1つのLisp式を実行する。
* Interaction: Lisp Interaction.  EmacsバッファーでLispを実行する。
* External Lisp::            Emacsを通じて別のLispと通信する。
@end menu

@node Compilation
@section Emacs下でのコンパイルの実行
@cindex inferior process
@cindex make
@cindex compilation errors
@cindex error log

  Emacsは、CやFortranのような言語のためのコンパイラーを実行でき、コンパイルログをEmacsのバッファーに取り込むことができます。エラーメッセージを解析して、エラーが発生した場所を示すこともできます。

@table @kbd
@item M-x compile
Emacs下で非同期にコンパイラーを実行し、エラーメッセージは@file{*compilation*}バッファーに送られます。
@item M-x recompile
最後に呼び出した@kbd{M-x compile}と同じコマンドで、コンパイラーを呼び出します。
@item M-x kill-compilation
サブプロセスで実行されているコンパイルをkillします。
@end table

@findex compile
  @code{make}、または他のコンパイルコマンドを実行するには、@kbd{M-x
compile}とタイプします。これはミニバッファーを使用してシェルのコマンドラインを読み取り、シェルをEmacsのサブプロセス(または@dfn{下位プロセス(inferior
process)})として、そのコマンドを実行します。出力は@file{*compilation*}という名前のバッファーに挿入されます。カレントバッファーのデフォルトディレクトリーが、コマンドを実行する作業ディレクトリーとして使用されます。したがって、通常はそのディレクトリーでコンパイルが行われます。

@vindex compile-command
  デフォルトのコンパイルコマンドは@samp{make
-k}で、これは@command{make}ユーティリティーを使ってコンパイルするプログラムにたいして通常正しいコマンドです(@samp{-k}フラグは@command{make}に、エラー後も可能な限りコンパイルを継続するよう指示します)。@ref{Top,,
Make, make, GNU Make Manual}を参照してください。前に@kbd{M-x
compile}を実行している場合、それに指定したコマンドは自動的に変数@code{compile-command}に格納されます。これは、次に@kbd{M-x
compile}とタイプしたときのデフォルトとなります。ファイルのファイルローカルな値で@code{compile-command}を指定することもできます(@ref{File
Variables}を参照してください)。

  コンパイルを開始すると、他のウィンドウで@file{*compilation*}バッファーが表示されますが、そのウィンドウは選択されません。コンパイルが実行中は、@file{*compilation*}バッファーのメジャーモードインジケーターに@samp{run}という単語が表示され、単語@samp{Compiling}がすべてのモードラインに表示されます。コンパイル実行中、常に@file{*compilation*}バッファーを表示している必要はありません。表示されていなくてもコンパイルは継続します。何らかの理由によりコンパイルが終了したときは、@file{*compilation*}バッファーのモードラインが@samp{exit}(その後に終了コード。@samp{[0]}の場合は通常終了)、または@samp{signal}(何らかのシグナルがプロセスを終了させた場合)に変化します。

  コンパイルの経過を見たいときは、バッファー@file{*compilation*}に切り替えて、ポイントをバッファーの最後に移動します。ポイントが最後にある場合、コンパイル出力はポイント位置に挿入されるので、ポイントは最後に留まります。そうでない場合は、バッファーの最後にコンパイル出力が追加される間も、ポイント位置は固定されたままです。

@cindex compilation buffer, keeping point at end
@vindex compilation-scroll-output
  変数@code{compilation-scroll-output}を非@code{nil}値に変更した場合、@file{*compilation*}バッファーは出力に追随して自動的にスクロールします。値が@code{first-error}の場合は、最初のエラーが出現した箇所でスクロールがストップし、ポイントはエラー箇所に留まります。その他の任意の非@code{nil}値の場合は、出力がなくなるまでスクロールが継続されます。

@findex recompile
  最後にコンパイルしたのと同じコマンドで再実行するには、@kbd{M-x recompile}とタイプします。これは最後に呼び出した@kbd{M-x
compile}からコンパイルコマンドを再利用します。これは@file{*compilation*}バッファーも再利用し、コンパイルもそのバッファーのデフォルトディレクトリー、つまり前にコンパイルが開始されたのと同じディレクトリーで行われます。

@findex kill-compilation
@vindex compilation-always-kill
  新しいコンパイルの開始は、すでに@file{*compilation*}で実行中のコンパイルをkillします。これは、そのバッファーが1度に1つのコンパイルしか処理できないからです。しかし実行中のコマンドを実際にkillする前に、@kbd{M-x
compile}は確認を求めます。常に確認なしで自動的にコンパイルをkillするには、変数@code{compilation-always-kill}を@code{t}に変更します。コマンド@kbd{M-x
kill-compilation}で、コンパイルプロセスをkillすることもできます。

  1度に2つのコンパイルを実行するには、最初に1つを開始してから(多分@code{rename-uniquely}を使用して。@ref{Misc
Buffer}を参照してください)@file{*compilation*}、バッファーをリネームして、それからバッファーを切り替えて他のコンパイルを開始します。これにより新しい@file{*compilation*}バッファーが作成されます。

@vindex compilation-environment
  コンパイルコマンドに渡される環境は、変数@code{compilation-environment}で制御できます。この変数の値は環境変数のセッティングのリストで、各要素は文字列@code{"@var{envvarname}=@var{value}"}の形式です。これらの環境変数のセッティングは、通常の値をオーバーライドします。

@node Compilation Mode
@section Compilationモード

@cindex Compilation mode
@cindex mode, Compilation
@cindex locus
  @file{*compilation*}バッファーは、Compilationモードと呼ばれるメジャーモードを使用します。Compilationモードは、バッファーのエラーメッセージをハイパーリンクに変換します。ポイントをそこに移動して@key{RET}をタイプするか、マウスでクリック(@ref{Mouse
References}を参照してください)すると、別のウィンドウでエラーメッセージの@dfn{locus}をvisitします。locusとは、エラーが発生したファイルの特定の位置を意味します。

@findex compile-goto-error
@vindex compilation-auto-jump-to-first-error
  変数@code{compilation-auto-jump-to-first-error}を非@code{nil}値に変更した場合、Emacsは、@file{*compilation*}バッファーに表れる最初のエラーメッセージのlocusを自動的にvisitします。

  Compilationモードは、以下の追加のコマンドを提供します。これらのコマンドは@file{*grep*}バッファーでも使用できます。このバッファーではエラーメッセージのかわりに、検索にたいするマッチにハイパーリンクが設定されます(@ref{Grep
Searching}を参照してください)。

@table @kbd
@item M-g M-n
@itemx M-g n
@itemx C-x `
次のエラーメッセージ(またはマッチ)のlocusをvisitします(@code{next-error})。
@item M-g M-p
@itemx M-g p
前のエラーメッセージ(またはマッチ)のlocusをvisitします(@code{previous-error})。
@item M-n
locusをvisitせずに、ポイントを次のエラーメッセージ(またはマッチ)に移動します(@code{compilation-next-error})。
@item M-p
locusをvisitせずに、ポイントを前のエラーメッセージ(またはマッチ)に移動します(@code{compilation-previous-error})。
@item M-@}
他のファイルで発生した次のエラーメッセージ(またはマッチ)にポイントを移動します(@code{compilation-next-file})。
@item M-@{
他のファイルで発生した前のエラーメッセージ(またはマッチ)にポイントを移動します(@code{compilation-previous-file})。
@item C-c C-f
Next Error
Followマイナーモードに切り替えます。これはcompilationバッファーでのカーソル移動にしたがって、ソースを自動的に表示するモードです。
@end table

@kindex M-g M-n
@kindex M-g n
@kindex C-x `
@findex next-error
@vindex next-error-highlight
  順番にエラーをvisitするには、@w{@kbd{C-x `}} (@code{next-error})とタイプするか、これと等価な@kbd{M-g
M-n}または@kbd{M-g
n}とタイプします。このコマンドはCompilationモードのバッファーだけでなく、任意のバッファーから呼び出すことができます。コンパイル後に最初に呼び出すときは、最初のエラーメッセージのlocusをvisitします。連続した@w{@kbd{C-x
`}}は、同じ方法で次のエラーをvisitします。@file{*compilation*}バッファーから@key{RET}またはマウスクリックで特定のエラーをvisitした場合、@w{@kbd{C-x
`}}はそのエラーの次のエラーからvisitしていきます。これ以上visitするエラーメッセージがない場合、@w{@kbd{C-x
`}}はエラーをシグナルします。@w{@kbd{C-u C-x
`}}はcompilationバッファーの先頭から再開して、最初のlocusをvisitします。

  @kbd{M-g M-p}または@kbd{M-g p} (@code{previous-error})は、反対方向にエラーを巡回します。

  コマンド@code{next-error}および@code{previous-error}は、バッファー@file{*compilation*}または@file{*grep*}にリストされたエラー(またはマッチ)だけに作用されるわけではありません。これらのコマンドは@kbd{M-x
occur} (@ref{Other Repeating
Search}を参照してください)のようなコマンドで生成されたエラー(またはマッチ)を巡回する方法も知っています。すでにエラーメッセージ(またはマッチ)を含むバッファーにいる場合、それらは巡回できるものの1つです。そうでない場合、Emacsは選択されたフレームのウィンドウの中でエラーメッセージ(またはマッチ)を含むバッファー、そして@code{next-error}または@code{previous-error}が前に巡回したバッファー、そして最後はすべての他のバッファーの中からバッファーを探します。巡回するために選択されたバッファーが現在ウィンドウに表示されていなければ、そのバッファーが表示されます。

@vindex compilation-skip-threshold
  デフォルトでは、コマンド@code{next-error}および@code{previous-error}は、重要でないメッセージはスキップします。変数@code{compilation-skip-threshold}が、これを制御します。デフォルト値は1で、これは警告(warning)より重要でないメッセージをスキップします。2の場合、エラー(error)より重要でないものをスキップし、0はメッセージをスキップしません。

  Emacsがエラーメッセージのlocusをvisitしているとき、関連するソース行が一時的にハイライトされます。このハイライトの持続時間は、変数@code{next-error-highlight}により決定されます。

@vindex compilation-context-lines
  @file{*compilation*}バッファーが左フリンジ(@ref{Fringes}を参照してください)のあるウィンドウで表示されている場合、locusをvisitするコマンドはカレントエラーメッセージを指す矢印をフリンジに配します。テキスト端末のように、左フリンジがないウィンドウの場合、これらのコマンドは、カレントメッセージがウィンドウの一番上にくるようにウィンドウをスクロールします。変数@code{compilation-context-lines}を整数値@var{n}に変更した場合、これらのコマンドは、フリンジの有無に関わらずメッセージがウィンドウの上から@var{n}行目にくるようにウィンドウをスクロールします。デフォルト値の@code{nil}では上述したように振る舞います。

@vindex compilation-error-regexp-alist
@vindex grep-regexp-alist
  コンパイラーからのメッセージを解析するために、Compilationモードは変数@code{compilation-error-regexp-alist}を使用します。これはさまざまなエラーメッセージのフォーマットをリストし、それらからlocusを抽出する方法をEmacsに指示します。同じような変数@code{grep-regexp-alist}は、@code{grep}コマンド(@ref{Grep
Searching}を参照してください)の出力を解析する方法を指示します。

@findex compilation-next-error
@findex compilation-previous-error
@findex compilation-next-file
@findex compilation-previous-file
  Compilationモードは、スクリーン単位でスクロールを行うために、キー@key{SPC}および@key{DEL}も定義します。@kbd{M-n}
(@code{compilation-next-error})および@kbd{M-p}
(@code{compilation-previous-error})は、次または前のエラーメッセージに移動します。@kbd{M-@{}
(@code{compilation-next-file})および@kbd{M-@}}
(@code{compilation-previous-file})は、違うソースファイルの、次または前のエラーメッセージに移動します。

@cindex Next Error Follow mode
@findex next-error-follow-minor-mode
  @kbd{C-c C-f}とタイプして、Next Error
Followモードに切り替えることができます。このマイナーモードでは、compilationバッファーでの通常のカーソル移動により、自動的にソースを表示するバッファーが更新されます。たとえばカーソルをエラーメッセージに移動すると、そのエラーにたいするlocusが表示されます。

  Compilationモードの機能は、Compilation
Minorモード呼ばれるマイナーモードでも利用可能です。これは通常のコンパイル出力のバッファーだけでなく、任意のバッファーのエラーメッセージを解析します。@kbd{M-x
compilation-minor-mode}とタイプすることにより、このマイナーモードが有効になります。たとえばRloginバッファー(@ref{Remote
Host}を参照してください)では、Compilation
minorモードはリモートのソースファイルに、FTPを通じて自動的にアクセスします(@ref{File Names}を参照してください)。

@node Compilation Shell
@section コンパイルのためのサブシェル

  @kbd{M-x
compile}コマンドは、コンパイルコマンドを実行するためにシェルを使いますが、オプションで非対話的なシェルを指定します。これは、シェルがプロンプトなしで開始されることを意味します。@file{*compilation*}バッファーで、通常のシェルプロンプトの見映えがよくない場合、それはシェルの初期化ファイルで、無条件にプロンプトをセットするという間違いを犯していることを意味します(この初期化ファイルは使用しているシェルに応じて@file{.bashrc}、@file{.profile}、@file{.cshrc}、@file{.shrc}などの名前がついています)。シェルの初期化ファイルでは、プロンプトがすでにあるときだけプロンプトをセットするべきです。これをbashで行うには、以下のようにします:

@example
if [ "$@{PS1+set@}" = set ]
then PS1=@dots{}
fi
@end example

@noindent
cshで行うには以下のようにします:

@example
if ($?prompt) set prompt = @dots{}
@end example

  Emacsは、コンパイラープロセスが非同期なサブプロセスで実行されることを要求しません。もしこれを行う場合、メインのコンパイラープロセスが終了した後で、サブプロセスがまだ実行中のときは、Emacsはこれらをkillするか、それらの出力はEmacsには到達しません。この問題を避けるには、メインのコンパイルプロセスが、それのサブプロセスの終了までwaitするようにします。シェルスクリプトでは、以下のように@samp{$!}と@samp{wait}を使用して、これを行うことができます:

@example
(sleep 10; echo 2nd)& pid=$!  # @r{サブプロセスのpidを記録}
echo first message
wait $pid                     # @r{サブプロセスのwait}
@end example

@noindent
バックグラウンドのプロセスがcompilationバッファーに何も出力せず、メインのコンパイルプロセスが終了したときに、これらがkillされるのを防ぐことだけが必要な場合は、以下で充分です:

@example
nohup @var{command}; sleep 1
@end example

@ifnottex
  MS-DOS``オペレーティングシステム''では、非同期なサブプロセスはサポートされていないので、@kbd{M-x
compile}はコンパイルコマンドを同期実行します(たとえばEmacsで他のことを行うには、コマンドが終了するまで待たなければなりません)。@ref{MS-DOS}を参照してください。
@end ifnottex

@node Grep Searching
@section Emacs下でのGrepによる検索

  Emacsからコンパイラーを実行して、コンパイルエラーの行をvisitできるように、@command{grep}を実行して見つかったマッチの行をvisitすることもできます。これは@command{grep}が報告するマッチを、``エラー''のように扱うことで機能します。出力バッファーはGrepモードを使用します。これはCompilationモードの変種です(@ref{Compilation
Mode}を参照してください)。

@table @kbd
@item M-x grep
@itemx M-x lgrep
Emacs下で@command{grep}を非同期で実行し、@file{*grep*}という名前のバッファーにマッチした行をリストします。
@item M-x grep-find
@itemx M-x find-grep
@itemx M-x rgrep
@code{find}を通じて@command{grep}を実行し、出力を@file{*grep*}バッファーに収集します。
@item M-x zrgrep
@code{zgrep}を実行して、出力を@file{*grep*}バッファーに収集します。
@item M-x kill-grep
実行中の@command{grep}サブプロセスをkillします。
@end table

@findex grep
  @command{grep}を実行するには、@kbd{M-x
grep}とタイプしてから、どのように@command{grep}を実行するかを指定するコマンドラインを入力します。これは通常、@command{grep}を実行するとき与える引数と同じです。@command{grep}スタイルのregexp(通常、シェルのスペシャル文字をクォートするためシングルクォートで囲む)の後に、ファイル名(ワイルドカードも使用できる)を続けます。@kbd{M-x
grep}にプレフィクス引数を指定した場合、バッファーのポイント位置周辺のtag(@ref{Tags}を参照してください)を探して、それを@command{grep}コマンドのデフォルトにします。

  指定するコマンドは、単純に@command{grep}を実行するものである必要はありません。同じフォーマットで出力を生成するシェルコマンドを使用することができます。たとえば、以下のように、@command{grep}コマンドを連結することができます:

@example
grep -nH -e foo *.el | grep bar | grep toto
@end example

  @command{grep}コマンドの出力は、@file{*grep*}バッファーに送られます。オリジナルのファイルの対応する行は、コンパイルエラーと同様、@w{@kbd{C-x
`}}、@key{RET}などで見つけることができます。

  マッチをハイライトするために、その周囲に特別なマーカーを出力する@samp{--color}オプションを指定できるgrepプログラムもあります。この機能を使うには、@code{grep-highlight-matches}を@code{t}にセットします。これによりソースバッファーのマッチを表示するとき、ソース行全体ではなく、正確なマッチだけがハイライトされます。

@findex grep-find
@findex find-grep
  コマンド@kbd{M-x grep-find}(@kbd{M-x find-grep}でも利用可能)は、@kbd{M-x
grep}と似ていますが、コマンドにたいして提供される初期のデフォルトが異なります ---
このデフォルトは@code{find}と@command{grep}の両方を実行するもので、これによりディレクトリーツリーの各ファイルを検索できます。@ref{Dired
and Find}の@code{find-grep-dired}コマンドも参照してください。

@findex lgrep
@findex rgrep
@findex zrgrep
  コマンド@kbd{M-x lgrep} (local grep)および@kbd{M-x rgrep} (recursive
grep)は、@command{grep}および@code{grep-find}のユーザーフレンドリーなバージョンで、これらはマッチにたいする正規表現、検索するファイル、検索の基準となるディレクトリーを個別に尋ねます。検索での大文字小文字の区別は、@code{case-fold-search}の値で制御されます。コマンド@kbd{M-x
zrgrep}は@kbd{M-x
rgrep}と似ていますが、これは@command{grep}のかわりに@command{zgrep}を呼び出し、gzipされたファイルの内容を検索します。

  これらのコマンドは、変数@code{grep-template}(@code{lgrep}用)、および@code{grep-find-template}(@code{rgrep}用)にもとづいてシェルコマンドを構築します。検索するファイルには、変数@code{grep-files-aliases}で定義されたエイリアスを使用できます。

@vindex grep-find-ignored-directories
  変数@code{grep-find-ignored-directories}にリストされたディレクトリーは、@kbd{M-x
rgrep}の検索で自動的にスキップされます。デフォルト値には、さまざまなバージョンコントロールシステムで使用されるデータディレクトリーが含まれます。

@node Flymake
@section オンザフライで構文エラーを見つける
@cindex checking syntax

  FlymakeモードはC、C++、Perl、HTML、@TeX{}/@LaTeX{}を含む、多くのプログラミング言語およびマークアップ言語の構文チェックを、オンザフライ(on-the-fly)で処理するマイナーモードです。これは通常の人間の言語にたいしてスペルチェックを処理する、Flyspellモード(@ref{Spelling}を参照してください)と、その方法において類似しています。Flymakeモードはファイルの編集にしたがい、そのバッファーの一時的なコピーを使用して、適切な構文チェックツールをバックグラウンドで実行します。それからエラーメッセージと警告メッセージを解析して、そのバッファーの間違った行をハイライトします。使用される構文チェックツールは、言語に依存します。たとえば通常、C/C++ファイルの場合は、Cコンパイラーです。Flymakeは、複雑なプロジェクトにたいしてのチェックでは、@code{make}のようなビルドツールを使うこともできます。

  Flymakeモードを有効にするには、@kbd{M-x flymake-mode}とタイプします。@kbd{M-x
flymake-goto-next-error}および@kbd{M-x
flymake-goto-prev-error}を使用して、これが見つけたエラーにジャンプすることができます。カレント行に関連するエラーメッセージを表示するには、@kbd{M-x
flymake-display-err-menu-for-current-line}とタイプしてください。

  Flymakeの使用についての詳細は、
@ifnottex
@ref{Top, Flymake, Flymake, flymake, The Flymake Manual}を参照してください。
@end ifnottex
@iftex
Emacsとともに配布されているFlymake Info manualを参照してください。
@end iftex

@node Debuggers
@section Emacs下でのデバッガーの実行
@cindex debuggers
@cindex GUD library
@cindex GDB
@cindex DBX
@cindex SDB
@cindex XDB
@cindex Perldb
@cindex JDB
@cindex PDB

GUD(Grand Unified
Debugger)ライブラリーは、広範なシンボリックデバッガーにたいするEmacsのインターフェースを提供します。これはGNUデバッガー(GDB)、同様にDBX、SDB、XDB、Paerlのデバッグモード、PythonデバッガーのPDB、JavaデバッガーのJDBを実行することができます。

  EmacsはGDBにたいする特別なインターフェースを提供します。これはデバッグされているプログラムの状態を表示する追加のEmacsウィンドウを使用します。@ref{GDB
Graphical Interface}を参照してください。

  Emacsは、Emacs Lispプログラムにたいするビルトインのデバッガーももっています。@ref{Debugging,, The Lisp
Debugger, elisp, the Emacs Lisp Reference Manual}を参照してください。

@menu
* Starting GUD::             デバッガーサブプロセスを開始する方法。
* Debugger Operation::       デバッガーとソースバッファーの関係。
* Commands of GUD::          一般的なコマンドのキーバインディング。
* GUD Customization::        GUDにたいして独自のコマンドを定義する。
* GDB Graphical Interface::  GDB機能を使用して、グラフィカルなデバッグ環境を実装する拡張モード。
@end menu

@node Starting GUD
@subsection GUDの開始

  デバッガーサブプロセスを開始する複数のコマンドがあり、それらは特定のデバッガープログラムに対応しています。

@table @kbd
@item M-x gdb
@findex gdb
GDBをサブプロセスとして実行し、IDE-likeなEmacsインターフェースを通じてやりとりをします。このコマンドに間する詳細は、@ref{GDB
Graphical Interface}を参照してください。

@item M-x gud-gdb
@findex gud-gdb
GDBサブプロセスとの入出力に、GUD interactionバッファーを使用してGDBを実行します((@ref{Debugger
Operation}を参照してください))。そのようなバッファーがすでに存在している場合はそのバッファーに切り替え、存在しない場合はバッファーを作成して切り替えます。

ここにリストされている他のコマンドは、他のデバッガープログラムにたいして同じことを行います。

@item M-x perldb
@findex perldb
Perlインタープリターをデバッグモードで実行します。

@item M-x jdb
@findex jdb
Javaデバッガーを実行します。

@item M-x pdb
@findex pdb
Pythonデバッガーを実行します。

@item M-x dbx
@findex dbx
DBXデバッガーを実行します。

@item M-x xdb
@findex xdb
@vindex gud-xdb-directories
XDBデバッガーを実行します。

@item M-x sdb
@findex sdb
SDBデバッガーを実行します。
@end table

  これらの各コマンドは、ミニバッファーを使ってデバッガーを呼び出すコマンドラインを読み取ります。ミニバッファーの初期内容は、デバッガーの標準的な実行ファイル名とオプションで、デバッグしたいと推測される実行ファイル名の場合もあります。シェルのワイルドカードと変数は、このコマンドラインでは使用できません。Emacsは@samp{-}で始まらない最初のコマンド引数を、実行ファイル名とみなします。

@cindex remote host, debugging on
  Trampは、同じリモートホスト上のデバッガーとプログラムによる、リモートデバッグ機能を提供します。詳細については、@ref{Running a
debugger on a remote host,,, tramp, The Tramp
Manual}を参照してください。これはGDBのリモートデバッグ機能とは別の物です、なぜなら、プログラムとデバッガーは違うマシンで実行されるからです(@ref{Remote
Debugging,, Debugging Remote Programs, gdb, The GNU debugger}を参照してください)。

@node Debugger Operation
@subsection デバッガーの操作
@cindex GUD interaction buffer

  @dfn{GUD
interactionバッファー}は、デバッガーサブプロセスにテキストコマンドを送ったり、それの出力を記録するのに使用されるEmacsバッファーです。これは@kbd{M-x
gud-gdb}や、
@iftex
前のセクションにリストされた他のコマンドで使用される、デバッガーとやりとりするための基本的なインターフェースです。
@end iftex
@ifnottex
@ref{Starting GUD}にリストされた他のコマンドで使用される、デバッガーとやりとりするための基本的なインターフェースです。
@end ifnottex
@kbd{M-x
gdb}コマンドは、ブレークポイント、スタックフレーム、その他のデバッガーの状態の様相を制御する、追加の特別なバッファーにより、この機能を拡張します(@ref{GDB
Graphical Interface}を参照してください)。

  GUD interactionはShellモードの変種を使用するので、Shellモードで定義されたEmacsコマンドが利用可能です(@ref{Shell
Mode}を参照してください)。ほとんどのデバッガーコマンドにたいして補完(@ref{Completion}を参照してください)が利用可能で、それらを繰り返すのに、通常のShellモードのヒストリーコマンドを使うことができます。
@iftex
GUD interactionバッファーで使用できる特別なコマンドについては、次のセクション
@end iftex
@ifnottex
GUD interactionバッファーで使用できる特別なコマンドについては、@ref{Commands of GUD}
@end ifnottex
を参照してください。

  プログラムをデバッグすると、Emacsは関連するソースファイルをEmacsバッファーにvisitして、カレント実行行には左フリンジに矢印が表示されます(テキスト端末では最初の2列に@samp{=>}の矢印が表示されます)。そのようなバッファーでのポイントの移動は、矢印を移動しません。これらのソースファイルの編集はできますが、行の挿入や削除により矢印の位置は失われることに注意してください。なぜならEmacsには編集されたソース行が、デバッガーサブプロセスから報告されるどの行に対応するか、知る手立てがないからです。この情報を更新するには通常、プログラムのリコンパイルと再実行が必要です。

@cindex GUD Tooltip mode
@cindex mode, GUD Tooltip
@findex gud-tooltip-mode
@vindex gud-tooltip-echo-area
  GUD Tooltipモードは、GUDにツールチップサポートを追加するグローバルなマイナーモードです。このモードに切り替えるには、@kbd{M-x
gud-tooltip-mode}とタイプします。このモードはデフォルトで無効になっています。有効にした場合、変数、関数、マクロ(@dfn{識別子}として総称される)にマウスを移動すると、それらの値がツールチップで表示されます(@ref{Tooltips}を参照してください)。かわりにマウスをドラッグして識別子または式をマークしてから、マウスをマークした領域から離すと、式の値がツールチップに表示されます。GUD
Tooltipモードは、GUD
interactionバッファー、および@code{gud-tooltip-modes}にリストされたメジャーモードの、すべてのソースバッファーで効果があります。変数@code{gud-tooltip-echo-area}が非@code{nil}の場合、またはツールチップモードがオフの場合は、ツールチップではなくエコーエリアに値が表示されます。

  @kbd{M-x gud-gdb}でGUD
Tooltipモードを使用する場合、GDBにより表示される式の値は、マクロを展開する場合があり、これはデバッグされているプログラムに副作用をもたらすかもしれません。この理由により、@code{gud-gdb}ではツールチップの使用は無効になっています。@kbd{M-x
gdb}インターフェースを使用する場合、この問題は発生しません。なぜなら副作用を避ける特別なコードがあるからです。さらにプログラムが実行されていないときに、識別子に関連付けられたマクロの定義を表示することもできます。

@node Commands of GUD
@subsection GUDのコマンド

  GUDはブレークポイントのセットとクリアー、スタックフレームの選択、プログラムのステップ実行のためのコマンドを提供します。

@table @kbd
@item C-x C-a C-b
@kindex C-x C-a C-b
ポイントのあるソース行にブレークポイントをセットします。
@end table

  ソースバッファーから@kbd{C-x C-a C-b}
(@code{gud-break})が呼び出された場合、カレントソース行にデバッガーのブレークポイントをセットします。このコマンドはGUDを開始した後だけ利用可能です。デバッガーサブプロセスに関連付けられていないバッファーで呼び出すと、エラーをシグナルします。

@kindex C-x C-a @r{(GUD)}
  以下のコマンドは、GUD
interactionバッファーとグローバルの両方で利用可能ですが、キーバインドが異なります。キーが@kbd{C-c}で始まるものはGUD
interactionバッファーだけで利用可能で、@kbd{C-x
C-a}で始まるものはグローバルに利用可能です。コマンドのいくつかはツールバーを通じても利用可能です。また、特定のデバッガーではサポートされないものもあります。

@table @kbd
@item C-c C-l
@kindex C-c C-l @r{(GUD)}
@itemx C-x C-a C-l
@findex gud-refresh
GUD interactionバッファーで参照される最後のソース行を、別のウィンドウに表示します(@code{gud-refresh})。

@item C-c C-s
@kindex C-c C-s @r{(GUD)}
@itemx C-x C-a C-s
@findex gud-step
次の1行を実行します(@code{gud-step})。その行が関数呼び出しを含む場合、関数呼び出しに入った後に実行をストップします。

@item C-c C-n
@kindex C-c C-n @r{(GUD)}
@itemx C-x C-a C-n
@findex gud-next
次の1行を実行します(@code{gud-next})。その行が関数呼び出しを含む場合、関数の中でストップせずに関数をステップオーバーします。

@item C-c C-i
@kindex C-c C-i @r{(GUD)}
@itemx C-x C-a C-i
@findex gud-stepi
機械語の1命令を実行します(@code{gud-stepi})。

@item C-c C-p
@kindex C-c C-p @r{(GUD)}
@itemx C-x C-a C-p
@findex gud-print
ポイント位置の式を評価します(@code{gud-print})。表示したい正確な式をEmacsが表示しない場合、最初に式をリージョンとしてマークします。

@need 3000
@item C-c C-r
@kindex C-c C-r @r{(GUD)}
@itemx C-x C-a C-r
@findex gud-cont
停止位置を指定せずに実行を継続します。プログラムは、ブレークポイントに達する、プログラム終了、またはデバッガーがチェックしているシグナルを受けとるまで実行を続けます。

@need 1000
@item C-c C-d
@kindex C-c C-d @r{(GUD)}
@itemx C-x C-a C-d
@findex gud-remove
カレントソース行にブレークポイントがある場合、ブレークポイントを削除します。GUD
interactionバッファーでこのコマンドを使用する場合、プログラムが最後に停止した位置に適用されます。

@item C-c C-t
@kindex C-c C-t @r{(GUD)}
@itemx C-x C-a C-t
@findex gud-tbreak
カレントソース行に、一時的なブレークポイントをセットします(@code{gud-tbreak})。GUD
interactionバッファーでこのコマンドを使用した場合、プログラムが最後に停止した位置に適用されます。

@item C-c <
@kindex C-c < @r{(GUD)}
@itemx C-x C-a <
@findex gud-up
次の外側のスタックフレームを選択します(@code{gud-up})。これはGDBコマンドの@samp{up}と等価です。

@item C-c >
@kindex C-c > @r{(GUD)}
@itemx C-x C-a >
@findex gud-down
次の内側のスタックフレームを選択します(@code{gud-down})。これはGDBコマンドの@samp{down}と等価です。

@item C-c C-u
@kindex C-c C-u @r{(GUD)}
@itemx C-x C-a C-u
@findex gud-until
カレント行まで実行を継続します(@code{gud-until})。プログラムは、ブレークポイントに達する、プログラム終了、またはデバッガーがチェックしているシグナルを受けとる、またはカーソルがある行に到達するまで実行を続けます。

@item C-c C-f
@kindex C-c C-f @r{(GUD)}
@itemx C-x C-a C-f
@findex gud-finish
選択されたフレームがリターンするか、他の理由により停止するまでプログラムを実行します(@code{gud-finish})。
@end table

  GDBを使用している場合、追加のキーバインディングが利用可能です:

@table @kbd
@item C-x C-a C-j
@kindex C-x C-a C-j @r{(GUD)}
@findex gud-jump
ソースバッファーだけで有用です。@code{gud-jump}はプログラムの実行箇所をカレント行に転送します。別の言い方をすると、プログラムが次に実行するのは、このコマンドを与えた位置になります。新しく実行される行が前の関数とは異なる場合、多分奇妙な結果になるので、GDBは確認を求めます。詳細は、GDBマニュアルのエントリー@code{jump}を参照してください。

@item @key{TAB}
@kindex TAB @r{(GUD)}
@findex gud-gdb-complete-command
GDBの場合、シンボル名を補完します(@code{gud-gdb-complete-command})。このキーはGUD
interactionバッファーだけで利用可能です。
@end table

  これらのコマンドは、それが意味がある場合には、数引数を繰り返し回数と解釈します。

  @key{TAB}は補完コマンドに割り当てられているので、GDBでデバッグしているプログラムへのタブの入力には使えません。タブの入力には@kbd{C-q
@key{TAB}}とタイプしてください。

@node GUD Customization
@subsection GUDのカスタマイズ

@vindex gdb-mode-hook
@vindex dbx-mode-hook
@vindex sdb-mode-hook
@vindex xdb-mode-hook
@vindex perldb-mode-hook
@vindex pdb-mode-hook
@vindex jdb-mode-hook
  起動時にGUDは以下のフックの1つを実行します:@*GDBを使用している場合は@code{gdb-mode-hook}、@*DBXを使用している場合は@code{dbx-mode-hook}、@*SDBを使用している場合は@code{sdb-mode-hook}、@*XDBを使用している場合は@code{xdb-mode-hook}、@*Perlのデバッグモードを使用している場合は@code{perldb-mode-hook}、@*PDBを使用している場合は@code{pdb-mode-hook}、@*JDBを使用している場合は@code{jdb-mode-hook}を実行します。@*@ref{Hooks}を参照してください。

  Lispマクロ@code{gud-def}(@ref{Defining Macros,,, elisp, the Emacs Lisp
Reference Manual}を参照してください)は、デバッガーに特定のコマンド文字列を送るEmacsコマンドを定義して、GUD
interactionバッファーで、それにたいするキーバインドをセットアップする便利な方法を提供します:

@findex gud-def
@example
(gud-def @var{function} @var{cmdstring} @var{binding} @var{docstring})
@end example

  これはデバッガープロセスに@var{cmdstring}を送る、ドキュメント文字列が@var{docstring}の、@var{function}という名前のコマンドを定義します。コマンド@var{function}を、任意のバッファーで使用できます。@var{binding}が非@code{nil}の場合、@code{gud-def}はそのコマンドを、GUDバッファーのモードでは@kbd{C-c
@var{binding}}、グローバルには@kbd{C-x C-a @var{binding}}にバインドします。

  コマンド文字列@var{cmdstring}には、@var{function}が呼び出されたときに書き込まれるデータのための、特定の@samp{%}シーケンスを含めることができます:

@table @samp
@item %f
カレントソースファイルの名前です。カレントバッファーがGUDバッファーの場合、``カレントソースファイル''はプログラムがストップしているファイルです。

@item %l
カレントソース行の番号です。カレントバッファーがGUDバッファーの場合、``カレントソース行''はプログラムがストップしている行です。

@item %e
transient-mark-modeでは、リージョンがアクティブの場合はリージョンのテキストです。そうでない場合、ポイント位置またはそれに隣接する位置にあるCのlvalue(左辺値)、または関数呼び出し式です。

@item %a
ポイント位置またはそれに隣接する位置にある、16進アドレスのテキストです。

@item %p
呼び出された関数の数引数の10進数です。コマンドに数引数が指定されなかった場合、@samp{%p}は空文字列になります。

コマンド文字列に@samp{%p}を使用しない場合、定義したコマンドは数引数を無視します。

@item %d
カレントソースファイルのディレクトリー名です。

@item %c
ポイントを取り囲む式から派生された、完全に記述されたされたclass名(fully qualified class name)です(jdbのみ)。
@end table

@node GDB Graphical Interface
@subsection GDBのグラフィカルインターフェース

  コマンド@kbd{M-x
gdb}はブレークポイント、スタックフレーム、その他のデバッグ状態の様相を制御するために特化したバッファーで、IDE-likeなインターフェースでGDBを開始します。これは、たとえばマウスソースバッファーのフリンジをクリックすることにより、そこにブレークポイントをセットするなどの、マウスによりデバッグセッションを制御する追加の方法も提供します。

@vindex gud-gdb-command-name
  これらの追加機能を使わずにGUD interactionバッファーのインターフェースだけを使ってGDBを実行するには、@kbd{M-x gud-gdb}
(@ref{Starting GUD}を参照してください)を使用します。これは、(現在のところ@kbd{M-x
gdb}ではサポートされていない)1つのEmacsセッションで複数のプログラムをデバッグしたいときだけ使用しなければなりません。

  内部的には、@kbd{M-x
gdb}はGDBにたいして``スクリーンサイズ''に制限がないと告げます。正しい操作のために、デバッグセッションの間はGDBのスクリーンの高さと幅の値を変更してはいけません。

@menu
* GDB User Interface Layout::  複数表示されたバッファーの制御。
* Source Buffers::           プログラムを制御するためにフリンジ・余白でマウスを使う。
* Breakpoints Buffer::       ブレークポイントのコントロールパネル。
* Threads Buffer::           スレッドの表示。
* Stack Buffer::             callスタックからのフレームの選択。
* Other GDB Buffers::        GDBの状態を制御するその他のバッファー。
* Watch Expressions::        speedbarで変数の値をモニターする。
* Multithreaded Debugging::  複数スレッドのプログラムのデバッグ。
@end menu

@node GDB User Interface Layout
@subsubsection GDBのユーザーインターフェースのレイアウト
@cindex GDB User Interface layout

@vindex gdb-many-windows
  変数@code{gdb-many-windows}が@code{nil}(デフォルト)の場合、@kbd{M-x gdb}は通常GUD
interactionバッファーだけを表示します。しかし@code{gdb-show-main}が非@code{nil}の場合、2つのウィンドウで開始します。その場合、1つはGUD
interactionバッファーを表示して、もう一方はデバッグするプログラムの@code{main}関数のソースを表示します。

  @code{gdb-many-windows}が非@code{nil}の場合、@kbd{M-x gdb}は以下のフレームレイアウトを表示します。

@smallexample
@group
+--------------------------------+--------------------------------+
|   GUD interaction buffer       |   Locals/Registers buffer      |
|--------------------------------+--------------------------------+
|   Primary Source buffer        |   I/O buffer for debugged pgm  |
|--------------------------------+--------------------------------+
|   Stack buffer                 |   Breakpoints/Threads buffer   |
+--------------------------------+--------------------------------+
@end group
@end smallexample

@findex gdb-restore-windows
@findex gdb-many-windows
  ウィンドウのレイアウトを変更した場合、@kbd{M-x
gdb-restore-windows}とタイプして``複数ウィンドウ''のレイアウトをリストアできます。複数ウィンドウレイアウトと、GUD
interactionバッファーとソースファイルだけの単純なレイアウトを切り替えるには、@kbd{M-x
gdb-many-windows}とタイプしてください。

  同じフレームまたは異なるフレームに、GDBに関連した追加のバッファーを表示するように指定できます。@code{M-x
gdb-display-@var{buffertype}-buffer}または@code{M-x
gdb-frame-@var{buffertype}-buffer}とタイプして、望むバッファーを選択します。ここで@var{buffertype}は@samp{breakpoints}のような、該当するバッファータイプです。@samp{GUD}メニューの、サブメニュー@samp{GDB-Windows}または@samp{GDB-Frames}により、メニューバーから同じことができます。

  デバッグを終えたら@kbd{C-x k}でGUD
interactionバッファーをkillすれば、このセッションでの関連するすべてのバッファーをkillできます。しかしEmacsでソースコードの編集とリコンパイル終えて、さらにデバッグを続けたいときは、これを行う必要はありません。実行を再開すると、GDBは自動的に新しい実行ファイルを見つけます。GUD
interactionバッファーを残しておけば、シェルヒストリー、同様にGDBブレークポイントを残すことができる利点があります。最近編集したソースファイルのブレークポイントが、正しい場所にあるかチェックする必要があります。

@node Source Buffers
@subsubsection Sourceバッファー
@cindex fringes, for debugging

@table @asis
@item @kbd{Mouse-1} (in fringe)
その行にブレークポイントをセットまたはクリアーします。

@item @kbd{C-Mouse-1} (in fringe)
その行のブレークポイントを有効または無効にします。

@item @kbd{Mouse-3} (in fringe)
その行まで実行を継続します。

@item @kbd{C-Mouse-3} (in fringe)
その行にジャンプします。
@end table

  グラフィカルなディスプレーでは、sourceバッファーのフリンジを@kbd{Mouse-1}でクリックして、その行にブレークポイントをセットできます(@ref{Fringes}を参照してください)。クリックした場所に赤いドットが表示されます。すでにそこにブレークポイントが存在する場合、クリックでそれを削除します。既存のブレークポイントを@kbd{C-Mouse-1}でクリックすることにより、有効または無効にします。クリアーされておらず無効になったブレークポイントは、グレイのドットで示されます。

  テキスト端末またはフリンジが無効な場合、有効なブレークポイントはウィンドウの左端に、@samp{B}という文字で示されます。無効なブレークポイントは@samp{b}で示されます(余白はブレークポイントがあるときだけ表示されます)。

  sourceバッファーの左フリンジの塗りつぶされた矢印は、デバッグされているプログラムがストップした最内フレームの行を示します。中抜きの矢印はより高いレベルのフレームの現在実行されている行を示します。フリンジの矢印を@kbd{Mouse-1}でドラッグすると、ボタンを離した行まで実行が進みます。かわりにフリンジを@kbd{Mouse-3}でクリックすることにより、その行まで実行を進めることができます。フリンジを@kbd{C-Mouse-3}でクリックすることにより、間にある行を実行せずに、その行にジャンプできます。このコマンドは後方へもジャンプできるので、すでに実行中のコードの実行の詳細を調べるのに便利です。

@node Breakpoints Buffer
@subsubsection Breakpointsバッファー

  GDB
Breakpointsバッファーは、デバッガーセッションのブレークポイント(breakpoint)、ウォッチポイント(watchpoint)、キャッチポイント(catchpoint)を表示します。@ref{Breakpoints,,,
gdb, The GNU
debugger}を参照してください。これは以下のコマンドを提供します。これらのコマンドのほとんどは@dfn{カレントブレークポイント}(ポイントのあるブレークポイント)に適用されます。

@table @kbd
@item @key{SPC}
@kindex SPC @r{(GDB Breakpoints buffer)}
@findex gdb-toggle-breakpoint
カレントブレークポイントを有効または無効にします(@code{gdb-toggle-breakpoint})。グラフィカルなディスプレーでは、これはsourceバッファーのフリンジのドットのカラーを変更します。ドットのカラーは、ブレークポイントが有効なときは赤、無効なときはグレーです。

@item D
@kindex D @r{(GDB Breakpoints buffer)}
@findex gdb-delete-breakpoint
カレントブレークポイントを削除します(@code{gdb-delete-breakpoint})。

@item @key{RET}
@kindex RET @r{(GDB Breakpoints buffer)}
@findex gdb-goto-breakpoint
カレントブレークポイントのソース行をvisitします(@code{gdb-goto-breakpoint})。

@item Mouse-2
@kindex Mouse-2 @r{(GDB Breakpoints buffer)}
クリックしたブレークポイントのソース行をvisitします。
@end table

@vindex gdb-show-threads-by-default
  @code{gdb-many-windows}が非@code{nil}の場合、GDB Breakpointsバッファーは、GDB
Threadsバッファーとウィンドウを共有します。一方から他方へ切り替えるには、ヘッダー行の関連するボタンを@kbd{Mouse-1}でクリックします。@code{gdb-show-threads-by-default}が非@code{nil}の場合、GDB
Threadsバッファーがデフォルトとして表示されます。

@node Threads Buffer
@subsubsection Threadsバッファー

@findex gdb-select-thread
  GDB Threadsバッファーは、デバッグされているプログラムのスレッドのサマリーを表示します。@ref{Threads, Threads,
Debugging programs with multiple threads, gdb, The GNU
debugger}を参照してください。スレッドを選択するには、ポイントをそこに移動して@key{RET}
(@code{gdb-select-thread})を押すか、それを@kbd{Mouse-2}でクリックします。これにより、それに関連するsourceバッファーが表示され、他のGDBバッファーの内容も更新されます。

  GDB Threadsバッファーに含まれる項目を選択するために、@code{gdb-buffers}グループ配下の変数をカスタマイズできます。

@table @code
@item gdb-thread-buffer-verbose-names
@vindex gdb-thread-buffer-verbose-names
@samp{Thread 0x4e2ab70 (LWP 1983)}のような長いスレッド名を表示します。

@item gdb-thread-buffer-arguments
@vindex gdb-thread-buffer-arguments
スレッドのトップフレームの引数を表示します。

@item gdb-thread-buffer-locations
@vindex gdb-thread-buffer-locations
ファイル情報またはライブラリー名を表示します。

@item gdb-thread-buffer-addresses
@vindex gdb-thread-buffer-addresses
threadバッファーのスレッドフレームのアドレスを表示します。
@end table

  複数のスレッドの情報を同時に閲覧するには、GDB Threadsバッファーの以下のコマンドを使用します。

@table @kbd
@item d
@kindex d @r{(GDB threads buffer)}
@findex gdb-display-disassembly-for-thread
カレント行のスレッドのdisassemblyバッファーを表示します(@code{gdb-display-disassembly-for-thread})。

@item f
@kindex f @r{(GDB threads buffer)}
@findex gdb-display-stack-for-thread
カレント行のスレッドのGDB Stackバッファーを表示します(@code{gdb-display-stack-for-thread})。

@item l
@kindex l @r{(GDB threads buffer)}
@findex gdb-display-locals-for-thread
カレント行のスレッドのGDB Localsバッファーを表示します(@code{gdb-display-locals-for-thread})。

@item r
@kindex r @r{(GDB threads buffer)}
@findex gdb-display-registers-for-thread
カレント行のスレッドのGDB
Registersバッファーを表示します(@code{gdb-display-registers-for-thread})。
@end table

@noindent
これらのコマンドの大文字@kbd{D}、@kbd{F}、@kbd{L}、@kbd{R}は、対応するバッファーを新しいフレームに表示します。

  特定のスレッドについての情報を表示するバッファーを作成した場合、それはそのスレッドにバインドされて、プログラムをデバッグする間、情報を表示し続けます。各GDBバッファーのモードインジケーターは、情報が表示されているスレッドの番号が表示されます。スレッドの番号はバインドされたバッファーのバッファー名にも含まれます。

  GDB
Threadsバッファーでは、さらに他のコマンドも利用可能で、それはプログラムの実行を制御するのに使われるGDBのモードに依存します。@ref{Multithreaded
Debugging}を参照してください。

@node Stack Buffer
@subsubsection Stackバッファー

  GDB Stackバッファーは、@dfn{コールスタック(call
stack)}を表示します。これは、1行がデバッガーセッションでのネストされたサブルーチン呼び出し(@dfn{stack frames:
スタックフレーム})にそれぞれ対応します。@ref{Backtrace,, Backtraces, gdb, The GNU
debugger}を参照してください。

@findex gdb-frames-select
  グラフィカルなディスプレーでは、選択されたスタックフレームは、フリンジの矢印で示されます。テキスト端末、またはフリンジが無効な場合、選択されたスタックフレームは反転して表示されます。スタックフレームを選択するには、ポイントをその行に移動して@key{RET}
(@code{gdb-frames-select})とタイプするか、それを@kbd{Mouse-2}でクリックします。これを行うことにより、Localsバッファーも更新されます
@ifnottex
(@ref{Other GDB Buffers}を参照してください)。
@end ifnottex
@iftex
(次のセクションで説明します)。
@end iftex

@node Other GDB Buffers
@subsubsection その他のGDBバッファー

@table @asis
@item Localsバッファー
このバッファーは、カレントフレームのローカル変数の値を、簡単なデータ型で表示します(@ref{Frame Info, Frame Info,
Information on a frame, gdb, The GNU
debugger}を参照してください)。値を編集したいときは、そこで@key{RET}を押すか、@kbd{Mouse-2}でクリックしてください。

配列と構造体については、その型だけが表示されます。GDB
6.4以降では、ポイント位置で@key{RET}をタイプ、または@kbd{Mouse-2}でクリックすることにより、ローカル変数の値を調べることができます。それより前のバージョンのGDBでは、型の説明(@samp{[struct/union]}または@samp{[array]})にたいして、@key{RET}または@kbd{Mouse-2}を使用します。@ref{Watch
Expressions}を参照してください。

@item Registersバッファー
@findex toggle-gdb-all-registers
このバッファーは、レジスターに保持されている値を表示します(@ref{Registers,,, gdb, The GNU
debugger}を参照してください)。値を編集したいときは、そのレジスターで@key{RET}を押すか、@kbd{Mouse-2}をクリックします。GDB6.4以降では、最近変化したレジスター値は、@code{font-lock-warning-face}で表示されます。

@item Assemblerバッファー
assemblerバッファーは、カレントフレームをマシン語コードで表示します。矢印はカレント命令を指し、sourceバッファーのようにブレークポイントのセットと削除ができます。ブレークポイントのアイコンも、フリンジまたは余白に表示されます。

@item Memoryバッファー
memoryバッファーは、プログラムのメモリーセクションを調べるためのバッファーです(@ref{Memory, Memory, Examining
memory, gdb, The GNU
debugger}を参照してください)。ヘッダー行の適切な箇所を@kbd{Mouse-1}でクリックすることにより、そのバッファーが表示するメモリーの開始アドレス、またはデータアイテムの数が変化します(または@kbd{S}および@kbd{N}を使用)。ヘッダー行を@kbd{Mouse-3}でクリックすることにより、データアイテムのフォーマット、またはユニットサイズのどちらを表示するか選択します。
@end table

@code{gdb-many-windows}が非@code{nil}の場合、breakpointsバッファーとthreadsバッファーがウィンドウを共有するように、localsバッファーとregistersバッファーもウィンドウを共有します。一方から他方へ切り替えるには、ヘッダー行の関連するボタンを@kbd{Mouse-1}でクリックしてください。

@node Watch Expressions
@subsubsection ウォッチ式
@cindex Watching expressions in GDB

@findex gud-watch
@kindex C-x C-a C-w @r{(GUD)}
  プログラムを停止するたびに、変数がどのように変化するか見たいときは、ポイントを変数名に移動して、ツールバーのウォッチアイコンをクリック(@code{gud-watch})するか、@kbd{C-x
C-a C-w}とタイプします。プレフィクス引数を指定した場合、変数名をミニバッファーで入力することができます。

  各ウォッチ式は、speedbarに表示されます(@ref{Speedbar}を参照してください)。配列や、構造体、共有体のような複雑なデータ型はツリー形式で表示されます。ツリーの子ノード、および単純なデータ型では、式の名前とその値が表示され、speedbarフレームが選択されたときは型がツールチップで表示されます。それより高いレベルでは名前、型、ポインターのアドレス値、そうでない場合は名前と型だけが表示されます。ルート式では、それらがどこで定義されているかを識別するために、ツールチップでフレームアドレスも表示されます

  複雑なデータ型を展開または折り畳むには、式の左のタグを@kbd{Mouse-2}をクリックするか@key{SPC}を押します。式の子にあたるデータの数が、変数@code{gdb-max-children}の値を超える場合、Emacsは式を展開する前に確認を求めます。

@kindex D @r{(GDB speedbar)}
@findex gdb-var-delete
  複雑なウォッチ式を削除するには、speedbarのルート式にポイントを移動して、@kbd{D}
(@code{gdb-var-delete})とタイプしてください。

@kindex RET @r{(GDB speedbar)}
@findex gdb-edit-value
  単純なデータ型の変数、または複雑なデータ型の単純な要素を編集するには、speedbarのその箇所にポイントを移動して、@key{RET}
(@code{gdb-edit-value})とタイプするか、値を@kbd{Mouse-2}でクリックして、それを編集します。どちらの方法も、ミニバッファーを使って新しい値を読み取ります。

@vindex gdb-show-changed-values
  変数@code{gdb-show-changed-values}を非@code{nil}値(デフォルト)にセットした場合、Emacsは最近変化した値を@code{font-lock-warning-face}でハイライトし、スコープから外れた変数は目立たない@code{shadow}フェイスで表示します。変数がスコープから外れた場合、値を変更することはできません。

@vindex gdb-delete-out-of-scope
  変数@code{gdb-delete-out-of-scope}が非@code{nil}(デフォルト)の場合、Emacsはスコープから外れたときウォッチ式を自動的に削除します。この変数を@code{nil}にしておけば、同じ関数に再入したとき、新たにウォッチ式を作成しなくてよいので便利かもしれません。

@vindex gdb-use-colon-colon-notation
  変数@code{gdb-use-colon-colon-notation}が非@code{nil}の場合、Emacsは@samp{@var{function}::@var{variable}}というフォーマットを使います。これにより同じ変数名を共有するウォッチ式を表示することができます。デフォルト値は@code{nil}です。

@vindex gdb-speedbar-auto-raise
ウォッチ式の表示が更新されるたびに、自動的にspeedbarを前に表示するには、@code{gdb-speedbar-auto-raise}を非@code{nil}にセットします。これはEmacsフレームを全画面表示にしてデバッグしているとき便利です。

@node Multithreaded Debugging
@subsubsection マルチスレッドのデバッグ
@cindex Multithreaded debugging in GDB
@cindex Non-stop debugging in GDB

  GDBの@dfn{all-stop
mode}では、プログラムが停止すると、すべてのスレッドの実行が停止します。同様に、プログラムを再開すると、すべてのスレッドが実行を開始します。@ref{All-Stop
Mode, , All-Stop Mode, gdb, The GNU
debugger}を参照してください。マルチスレッド化されたいくつかのターゲットにたいして、GDBはこれを超える操作のためのモードをサポートします。これは@dfn{non-stop
mode}と呼ばれ、他のスレッドが自由に実行を継続している間に、デバッガーで停止したプログラムのスレッドを調べることができます。@ref{Non-Stop
Mode, , Non-Stop Mode, gdb, The GNU
debugger}を参照してください。GDBのバージョン7.0以前では、non-stop
modeはサポートされておらず、すべてのターゲットにたいしては機能しません。

@vindex gdb-non-stop-setting
  変数@code{gdb-non-stop-setting}は、EmacsがGDBをall-stop modeとnon-stop
modeのどちらで実行するかを決定します。デフォルトは@code{t}で、これは利用可能な場合はnon-stop
modeを使うことを意味します。値を@code{nil}に変更した場合、またはnon-stop
modeが利用不可の場合、EmacsはGDBをall-stop
modeで実行します。この変数はEmacsがデバッグセッションを開始したときに効果をもちます。値を変更した場合、アクティブなデバッグセッションを再起動する必要があります。

@vindex gdb-switch-when-another-stopped
  non-stop
modeモードでスレッドが停止すると、通常Emacsはそのスレッドに切り替えます。すでに選択したスレッドから停止した他のスレッドへの切り替えを行わないようにするには、変数@code{gdb-switch-when-another-stopped}を@code{nil}に変更してください。

@vindex gdb-switch-reasons
  Emacsが停止したスレッドに切り替えるかどうかの決定は、そのスレッドが停止した理由に依存します。変数@code{gdb-switch-reasons}をカスタマイズすることにより、スレッドの切り替えを行う停止理由を選択できます。

@vindex gdb-stopped-functions
  変数@code{gdb-stopped-functions}には、あるスレッドが停止したときに実行する関数を指定できます。

  non-stop modeでは、GUDの実行制御コマンドのための異なるモードを切り替えることができます。

@vindex gdb-gud-control-all-threads
@table @dfn
@item Non-stop/A

  @code{gdb-gud-control-all-threads}が@code{t}(デフォルト)の場合、中断および継続のためのコマンドはすべてのスレッドに適用されるので、@code{gud-stop-subjob}または@code{gud-cont}の1コマンドで、すべてのスレッドを停止または継続できます。少なくとも1つのスレッドが停止している場合、ツールバーに@samp{Go}ボタンが表示されます。また、少なくとも1つのスレッドが実行中の場合、@samp{Stop}ボタンが表示されます。

@item Non-stop/T

@code{gdb-gud-control-all-threads}が@code{nil}の場合、カレントスレッドだけを停止または継続します。GUDツールバーの@samp{Go}および@samp{Stop}のボタンの表示は、カレントスレッドの状態に依存します。
@end table

@code{gdb-gud-control-all-threads}のカレント値は、ツールバーまたは@samp{GUD->GDB-MI}メニューで変更できます。

  ステップコマンドは常にカレントスレッドに適用されます。

  non-stop
modeでは、スレッドを選択せずにスレッドを中断または継続できます。threadsバッファーで、ポイント位置のスレッドにたいして@kbd{i}をタイプすると中断、@kbd{c}で継続、@kbd{s}でステップ実行します。今後さらにそのようなコマンドが追加されるかもしれません。

  スレッドを中断した場合、停止理由は@samp{signal
received}になることに注意してください。この理由が@code{gdb-switch-reasons}に含まれている場合(デフォルトでは含まれています)、Emacsはそのスレッドに切り替えます。

@node Executing Lisp
@section Lisp式の実行

  Emacsには、Lispのいくつかの変種のためのメジャーモードがあります。これらは他のプログラミング言語のモードと同じ編集コマンドを使用します(@ref{Programs}を参照してください)。それに加えて、Lisp式を実行するための特別なコマンドを提供します。

@table @asis
@item Emacs Lispモード
Emacs
Lispのソースファイルを編集するためのモードです。このモードはカレントのトップレベルのLisp式を評価する@kbd{C-M-x}を定義します。@ref{Lisp
Eval}を参照してください。

@item Lisp Interactionモード
Emacs
Lispとの対話的なセッションのためのモードです。このモードはポイントの前の式を評価して、その値をバッファーに挿入する@kbd{C-j}を定義します。@ref{Lisp
Interaction}を参照してください。

@item Lispモード
Emacs
Lispではない、他のLispを実行するプログラムのソースファイルを編集するためのモードです。このモードは、カレントのトップレベルの式を外部のLispで評価する@kbd{C-M-x}を定義します。@ref{External
Lisp}を参照してください。

@item Inferior Lispモード
Emacsのサブプロセス(または@dfn{inferior process:
下位プロセス})として実行される外部Lispと、対話的にセッションするためのモードです。
@ifnottex
@ref{External Lisp}を参照してください。
@end ifnottex

@item Schemeモード
Lispモードと同様ですが、Schemeプログラムのためのモードです。

@item Inferior Schemeモード
Inferior Lispモードと同様ですが、Schemeのためのモードです。
@end table

@node Lisp Libraries
@section EmacsのためのLispコードによるライブラリー
@cindex libraries
@cindex loading Lisp code

  Emacs Lispのコードは、慣習として@file{.el}で終わる名前のファイルに保存されます。このようなファイルは、自動的にEmacs
Lispモードでvisitされます。

@cindex byte code
  Emacs Lispのコードは、loadが速く省スペースで、実行も速いバイトコードにコンパイルできます。慣習により、コンパイルされたEmacs
Lispのコードは@samp{.elc}で終わる名前の別のファイルに保存されます。たとえば、@file{foo.el}をコンパイルしたコードは@file{foo.elc}になります。@ref{Byte
Compilation,, Byte Compilation, elisp, the Emacs Lisp Reference
Manual}を参照してください。

@findex load-file
  Emacs Lispファイルを@dfn{ロード(load)}するには、@kbd{M-x
load-file}とタイプします。このコマンドはミニバッファーを使ってファイル名を読み取り、そのファイル内容をEmacs
Lispコードとして実行します。最初にファイルをvisitしておく必要はありません。このコマンドは、既存のEmacsバッファーからではなく、ディスクからファイルを直接読み込みます。

@findex load
@findex load-library
@vindex load-prefer-newer
@cindex load path for Emacs Lisp
  Emacs Lispファイルが、Emacs Lispの@dfn{ロードパス(load path:
以下で定義)}にインストールされている場合、@kbd{M-x load-file}ではなく@kbd{M-x
load-library}とタイプしてロードできます。@kbd{M-x
load-library}コマンドは、ファイル名ではなく@dfn{ライブラリー名(library name)}の入力を求めます。これはEmacs
Lispのロードパスの各ディレクトリーを検索して、そのライブラリー名にマッチするファイルを見つけようと試みます。ライブラリー名が@samp{@var{foo}}の場合、ファイル名@file{@var{foo}.elc}、@file{@var{foo}.el}、@file{@var{foo}}を見つけようと試みます。デフォルトの動作では、最初に見つかったファイルをロードします。このコマンドは@file{.el}より@file{.elc}を優先します。それはコンパイルされたファイルの方が、ロードと実行が速いからです。@file{@var{lib}.el}が@file{@var{lib}.elc}より新しい場合、警告を発します。この場合、誰かが@file{.el}を変更したもののリコンパイルを忘れたようだが、ともかく@file{.elc}をロードする、という警告です(この振る舞いにより、編集が終わっておらず、まだリコンパイルする準備ができていないEmacs
Lispのソースファイルを保存することができます)。しかしオプション@code{load-prefer-newer}を非@code{nil}値にセットした場合、上記の手順ではなく、Emacsは新しいファイルのバージョンをロードします。

  Emacs Lispプログラムは通常、@code{load}関数を使用してEmacs
Lispファイルをロードします。これは@code{load-library}と似ていますが、より低レベルで追加の引数を指定できます。@ref{How
Programs Do Loading,,, elisp, the Emacs Lisp Reference Manual}を参照してください。

@vindex load-path
  Emacs
Lispのロードパスは、変数@code{load-path}により指定されます。この変数の値は、ディレクトリー名(文字列)のリストです。これらのディレクトリーは、@kbd{M-x
load-library}コマンド、低レベルの@code{load}関数、その他のEmacs
Lispライブラリーを探すEmacs関数により、指定された順に検索されます。@code{load-path}のリストの要素には、特別な値@code{nil}も指定できます。これはカレントのデフォルトディレクトリーを意味しますが、これを使うのは大抵間違っています(リストに@code{nil}を含めたいと思うとき、大抵の場合は、本当に望んでいるのは@kbd{M-x
load-file}を使用することです)。

  @code{load-path}のデフォルト値は、Emacs自身がLispコードを格納するディレクトリーのリストです。他のディレクトリーに独自のライブラリーがある場合、ロードパスにそのディレクトリーを追加できます。このマニュアルで説明されている他の大半の変数とは異なり、@code{load-path}はCustomizeインターフェース(@ref{Easy
Customization}を参照してください)を通じての変更はできません。しかしinitファイルに以下のような行を記述して、ディレクトリーを追加できます(@ref{Init
File}を参照してください):

@example
(add-to-list 'load-path "/path/to/my/lisp/library")
@end example

@cindex autoload
  いくつかのコマンドは、@dfn{自動ロード(autoload)}されます。これらを実行するとき、Emacsは最初に関連するライブラリーを自動的にロードします。たとえば@kbd{M-x
compile}コマンド(@ref{Compilation}を参照してください)は、自動ロードされます。これを呼び出した場合、Emacsは最初に、自動的に@code{compile}ライブラリーをロードします。対照的にコマンド@kbd{M-x
recompile}は、自動ロードされません。そのため、このコマンドは@code{compile}ライブラリーをロードするまで利用できません。

@vindex help-enable-auto-load
  自動的なロードは、自動ロードされたコマンドのドキュメントを探すとき(@ref{Name
Help}を参照してください)にも発生します。それは、ドキュメントがライブラリーの他の関数や変数を参照する場合です(ライブラリーのロードにより@file{*Help*}バッファーのハイパーリンクが適切にセットアップされます)。この機能を無効にするには、変数@code{help-enable-auto-load}を@code{nil}に変更してください。

@vindex load-dangerous-libraries
@cindex Lisp files byte-compiled by XEmacs
  デフォルトではEmacsは、XEmacs ---Emacsの変更されたバージョン ---
でコンパイルされたコンパイル済みのLispファイルのロードを拒絶します。なぜならそれはEmacsのクラッシュをさせるからです。これらのロードを試みる場合は、変数@code{load-dangerous-libraries}に@code{t}をセットしてください。

@node Lisp Eval
@section Emacs Lisp式の評価
@cindex Emacs Lispモード
@cindex mode, Emacs Lisp
@cindex evaluation, Emacs Lisp

@findex emacs-lisp-mode
  Emacs LispモードはEmacs Lispを編集するためのメジャーモードです。これのモードコマンドは@kbd{M-x
emacs-lisp-mode}です。

  Emacsは、Emacs Lisp式を評価するためのコマンドをいくつか提供します。記述しているEmacs
Lispコードをテストするために、これらのコマンドをEmacs
Lispモードで使用できます。たとえば、関数を書き換えた後、以降の関数呼び出しでそれを有効にするために、関数定義を評価します。これらのコマンドはグローバルに利用可能で、Emacs
Lispモード以外でも使用できます。

@table @asis
@item @kbd{M-:}
1つのEmacs Lisp式をミニバッファーで読み取り、それを評価して、値をエコーエリアに出力します(@code{eval-expression})。
@item @kbd{C-x C-e}
ポイントの前のEmacs Lisp式を評価して、値をエコーエリアに出力します(@code{eval-last-sexp})。
@item @kbd{C-M-x} @r{(Emacs Lispモード)}
@itemx @kbd{M-x eval-defun}
ポイントの後またはポイントを含むdefunを評価して、値をエコーエリアに出力します(@code{eval-defun})。
@item @kbd{M-x eval-region}
リージョンのすべてのEmacs Lisp式を評価します。
@item @kbd{M-x eval-buffer}
バッファーのすべてのEmacs Lisp式を評価します。
@end table

@ifinfo
@c This uses ``colon'' instead of a literal `:' because Info cannot
@c cope with a `:' in a menu
@kindex M-@key{colon}
@end ifinfo
@ifnotinfo
@kindex M-:
@end ifnotinfo
@findex eval-expression
  @kbd{M-:}
(@code{eval-expression})は、ミニバッファーを使って式を読み取り、それを評価します(式を評価する前に、カレントバッファーは、式をタイプするためのミニバッファーではなく、@kbd{M-:}をタイプしたときカレントだったバッファーに切り替わります)。

@kindex C-x C-e
@findex eval-last-sexp
  コマンド@kbd{C-x C-e} (@code{eval-last-sexp})は、そのバッファーのポイントの前にあるEmacs
Lisp式を評価して、その値をエコーエリアに表示します。評価した結果が整数のときは、他のフォーマット(8進、16進、文字)も一緒に値を表示します。

  @kbd{M-:}および@kbd{C-x
C-e}にプレフィクス引数を与えた場合、値をエコーエリアに表示するのではなく、カレントバッファーのポイント位置に値を挿入します。プレフィクス引数が0の場合、整数出力は他のフォーマット(8進、16進、文字)と一緒に挿入されます。プレフィクス引数は、@code{eval-expression-print-level}および@code{eval-expression-print-length}にしたがった出力の省略も防ぎます(以下参照)。

@kindex C-M-x @r{(Emacs Lisp mode)}
@findex eval-defun
  @code{eval-defun}コマンドは、Emacs
Lispモードでは@kbd{C-M-x}にバインドされています。これはポイントを含む、またはポイントの後ろのトップレベルのLisp式を評価して、値をエコーエリアに出力します。このコンテキストでは、トップレベルの式は``defun''として参照されますが、実際の@code{defun}(関数定義)である必要はありません。このコマンドは@code{defvar}式を特別に扱います。通常、@code{defvar}式を評価しても、それが定義する変数がすでに値をもっている場合は、何も起こりません。しかし、このコマンドは無条件に@code{defvar}で指定された初期値に変数をリセットします。これはEmacs
Lispプログラムをデバッグするとき便利です。式@code{defcustom}および@code{defface}も同様に扱われます。このセクションで説明している他のコマンドは、この特別な機能をもっていません。

  プレフィクス引数を指定すると、@kbd{C-M-x}はEmacs
LispデバッガーのEdebugのために関数定義をインストルメント(instrument: 処置)します。@ref{Instrumenting,
Instrumenting for Edebug,, elisp, the Emacs Lisp Reference Manual}を参照してください。

@findex eval-region
@findex eval-buffer
  コマンド@kbd{M-x
eval-region}は、リージョンのテキストを1つ以上のLisp式として解析して、それらを1つずつ評価します。@kbd{M-x
eval-buffer}も同様ですが、これはバッファー全体を評価します。

@vindex eval-expression-print-level
@vindex eval-expression-print-length
@vindex eval-expression-debug-on-error
  オプション@code{eval-expression-print-level}および@code{eval-expression-print-length}は、評価コマンドが結果を出力する前に省略する、リストの最大の深さと長さを制御します。@code{eval-expression}または@code{eval-last-sexp}にプレフィクス引数0を指定すると、リストはすべて出力されます。@code{eval-expression-debug-on-error}は、これらのコマンドが使用されるとき、評価エラーによりデバッガーを呼び出すかを制御します、デフォルトは@code{t}です。

@node Lisp Interaction
@section Lisp Interactionバッファー

@findex lisp-interaction-mode
  Emacsを開始したとき、@file{*scratch*}という名前のバッファーが含まれます、これはEmacs
Lisp式の対話的な評価を提供します。このバッファーのメジャーモードは、Lisp Interactionモードです。@kbd{M-x
lisp-interaction-mode}とタイプしても、Lisp Interactionモードを有効にできます。

@findex eval-print-last-sexp
@kindex C-j @r{(Lisp Interaction mode)}
  @file{*scratch*}バッファー、およびその他のLisp Interactionモードのバッファーでは、@kbd{C-j}
(@code{eval-print-last-sexp})はポイントの前のLisp式を評価して、値をポイント位置に挿入します。したがってバッファーに式をタイプするたび、その後ろで@kbd{C-j}をタイプすることにより、そのバッファーは式の評価とその値を記録した写しになります。その他すべてのLisp
Interactionモードのコマンドは、Emacs Lispモードと同じです。

@vindex initial-scratch-message
  起動時には、@file{*scratch*}バッファーは、それが何かを説明するLispコメント形式の短いメッセージを含んでいます。このメッセージは変数@code{initial-scratch-message}により制御され、値は文字列または@code{nil}(メッセージを抑止するという意味)です。

@findex ielm
  Emacs Lisp式を対話的に評価する別の方法は、Inferior Emacs Lispモードを使う方法です。これはEmacs
Lisp式の評価にShellモード(@ref{Shell Mode}を参照してください)に似たインターフェースを提供します。@kbd{M-x
ielm}とタイプすることにより、このモードを使用する@file{*ielm*}というバッファーが作成されます。詳細は、コマンドのドキュメントを参照してください。

@node External Lisp
@section 外部Lispの実行
@cindex Lispモード
@cindex mode, Lisp
@cindex Common Lisp

  Lispモードは、Common
Lispのような一般用途のためのLisp方言で記述されたプログラムを記述するためのメジャーモードです。これのモードコマンドは@kbd{M-x
lisp-mode}です。Emacsは名前が@file{.l}、@file{.lsp}、@file{.lisp}で終わるファイルにたいして、自動的にLispモードを使用します。

@findex run-lisp
@vindex inferior-lisp-program
@kindex C-x C-z
  外部LispセッションをEmacsのサブプロセス、または@dfn{下位プロセス(inferior
process)}として実行して、式を評価するために渡すことができます。外部Lispセッションを開始するには、@kbd{M-x
run-lisp}とタイプします。これは@command{lisp}という名前のプログラムを実行して、@file{*inferior-lisp*}という名前のEmacsバッファーを通じて入出力を行うようにセットアップします。@kbd{M-x
run-lisp}で実行されるLispプログラムの名前を変更するには、変数@code{inferior-lisp-program}を変更してください。

  @file{*lisp*}バッファーのためのメジャーモードはInferior
Lispモードで、これはLispモードの性質とShellモード(@ref{Shell
Mode}を参照してください)の性質をあわせ持っています。Lispセッションに入力を送るには、@file{*lisp*}バッファーの最後に移動して、入力をタイプしてから@key{RET}をタイプします。Lispセッションからの端末出力は、自動的にそのバッファーに挿入されます。

@kindex C-M-x @r{(Lisp mode)}
@findex lisp-eval-defun
  LispプログラムをLispモードで編集する場合、@kbd{C-M-x}
(@code{lisp-eval-defun})とタイプして、Lispモードのバッファーから、@kbd{M-x
run-lisp}で開始したLispセッションに式を送ることができます。送信される式はポイント位置、またはポイントの後ろのトップレベルのLisp式です。結果となる値は通常どおり、@file{*inferior-lisp*}バッファーに送られます。Lispモードでの@kbd{C-M-x}の効果は、それが評価されるEmacsに送られるのではなく、異なるLisp環境に送られる点を除けば、Emacs
Lispモード(@ref{Lisp Eval}を参照してください)での効果とよく似ていることに注意してください。

@findex scheme-mode
@findex run-scheme
@cindex Schemeモード
@cindex mode, Scheme
@kindex C-M-x @r{(Scheme mode)}
  Schemeコードを編集して、式をSchemeサブプロセスに送る機能は、よく似ています。Schemeソースファイルは、Schemeモードで編集されます。このモードは@kbd{M-x
scheme-mode}で明示的に有効にできます。@kbd{M-x
run-scheme}とタイプすることにより、Schemeセッションを開始し、@kbd{C-M-x}とタイプして式の送ることができます(Schemeと対話するためのバッファーは、@file{*scheme*}という名前です)。
